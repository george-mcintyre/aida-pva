// **********************************************************************
//
// Generated by the ORBacus IDL to Java Translator
//
// Copyright (c) 2001
// IONA Technologies, Inc.
// Waltham, MA, USA
//
// All Rights Reserved
//
// **********************************************************************

// Version: 4.1.0

package edu.stanford.slac.aida.dp.dpCa;

import java.nio.CharBuffer;
import java.util.Calendar;
import java.util.Date;
import java.util.HashMap;
import java.util.Iterator;
import java.util.Timer;
import java.util.TimerTask;
import org.omg.CORBA.ORB;
import org.omg.PortableServer.*;
import gov.aps.jca.*;
import gov.aps.jca.dbr.*;
import edu.stanford.slac.err.*;
import edu.stanford.slac.aida.lib.util.common.*;
import edu.stanford.slac.except.*;

//
// IDL:dp.aida.slac.stanford.edu/dpCa/DpCaI:1.0
//
/**
 * This class defines the AIDA Data Provider for EPICS Channel Access.
 *
 * DpCaI_impl implements the AIDA Data Provider "DpCaI" CORBA
 * interface, by extending DpCaIPOA
 *
 * The inderlying EPICS Data Source is accessed through the (new COSYLAB) JCA
 * interface.
 *
 */
/* Implementation Notes:
 *
 * TODO: If this service starts getting any amount of traffic, we should thread
 *    it.  Current model of sending synchronous CA requests and waiting for
 *    response won't work so well with even just a few concurrent clients.  It
 *    shouldn't be too difficult to add threading support, though it will
 *    require fundamental changes.
 *
 * TODO: Q. Should Any get() necessarily get DBR_TIME?
 *    Maybe Any get() should get DBR_TIME by default, but some other
 *    DBR if requested by arg (eg "DBR"="DBR_STATUS");
 *
 * TODO: Q. Perf: Any get() should probably return predefined structures
 *    depending on DBR argument, or if none, return predefined DBR_TIME. This
 *    will avoid creating dynamic Any.
 *
 * TODO: Q. Should type specified get methods (eg get_byte) throw TypeMismatch
 *    exception if DBR type does not match method? As implemented the type
 *    specified get methods such as get_double() use DBR coersion
 *    (ie, double r = dbr.dataAt(i).doubleValue()) rather than direct access
 *    assuming a matching type (double r = dbr.valueAtpwd(i)) 
 *    which presumably would be faster.
 *
 */
public class DpCaI_impl extends DpCaIPOA
{
    // TODO: Perf: Are these timeouts appropriate?
    // wait up to 15.0sec for JCA/CA API query completion
    private static final double PENDIO_TIMEOUT = 15.0;


    private static Calendar calendar = Calendar.getInstance();
    private static AidaDateFormat dateFormat = new AidaDateFormat();

    // EPICS time zero
    private static Date epics_tzero;
    
    private static boolean m_doneInit = false; // Whether = inited this server.
    private _PersistentDaObject m_da;          // For orb access.
    private ORB m_orb;                         // CORBA ORB for this server.
    private org.omg.PortableServer.POA m_poa;  // Portable Object Adapter
    private JCALibrary m_jca;                  // Java Channel Access singleton
    private Context m_ctxt;                    // JCA config Context,
                                               // single threaded or threadsafe
    private Err m_err;                         // Err messaging singleton.


    /**
       Encapsulates jca Channel, associating some other info along with it
     */
    private class MetaChannel
    {
        private String[] enumerationLabels = new String[0];
        public Channel channel;

        
        MetaChannel (Channel channel)
            throws CAException, IllegalStateException, TimeoutException
        {
            this.channel = channel;

            // gather labels for enum types
            if (channel.getFieldType().isENUM())
            {
                DBR_LABELS_Enum labels = (DBR_LABELS_Enum)channel.get (
                    DBRType.LABELS_ENUM, 1);
                m_ctxt.pendIO (PENDIO_TIMEOUT);
                enumerationLabels = labels.getLabels();
            }
        }
        
        public String getEnumerationLabel (int idx)
        {
            if (idx > enumerationLabels.length)
                return "Unknown Label: index out of range";
            return enumerationLabels[idx];
        }
    }
    

    /* Cache of recently used channels.
       
       Requested channels are created on demand if they don't already exist in
       the cache.  Channels note the time when they are requested.
       
       Periodic scans of the cached channels flush those that have not been
       referenced recently enough.

       There's an inherent race condition in this system: a channel that is
       requested via the cache, and held longer than its linger time may not
       be used with any confidence.

       The assumption is that none of the server code holds on to a channel
       across requests, and none of the requests should take anywhere near the
       linger time to complete.  If the premise changes, then we'll need
       reference counting.
     */
    private class ChannelCache
    {
        /* The approximate amount of time a channel will may remain connected
           after its most recent reference.
         */
        static final int CHANNEL_LINGER_MILLIS = 5 * 60 * 1000;

        
        /* The flushing thread runs at this interval to disconnect channels
           that have not been referenced recently enough.
         */
        static final int FLUSH_INTERVAL_MILLIS = 30 * 1000;


        /* Associates reference time with a channel object.
         */
        private class CachedChannel extends MetaChannel
        {
            private long referenceTimeMillis = 0;

            public CachedChannel (Channel channel)
                throws CAException, IllegalStateException, TimeoutException
            {
                super (channel);
            }

            public void updateReferenceTime ()
            {
                referenceTimeMillis = System.currentTimeMillis();
            }

            public boolean isNotReferencedSince (long sinceMillis)
            {
                return (referenceTimeMillis < sinceMillis);
            }

            public void destroyChannel ()
                throws CAException, IllegalArgumentException
            {
                channel.destroy();
            }
        }


        /* Maps channel name -> CachedChannel
         */
        private final HashMap cachedChannels = new HashMap();


        /* Creates the flushing thread.
         */
        public ChannelCache ()
        {
            // create a daemon-threaded timer and assign it a new fixed-delay
            // task to flush decrepit channels
            new Timer (true).schedule (

                // task
                new TimerTask() {
                     public void run () {
                        destroyDecrepitChannels();
                    }
                },
                
                // initial delay
                CHANNEL_LINGER_MILLIS,
                
                // subsequent periodicity
                FLUSH_INTERVAL_MILLIS);
        }

        
        /* Finds in cache or adds as necessary.
         */
        synchronized public MetaChannel getMetaChannel (String name)
            throws
            CAException,
            IllegalArgumentException,
            IllegalStateException,
            TimeoutException
        {
            CachedChannel cc = (CachedChannel)cachedChannels.get (name);
            
            if (cc == null)
            {
                Channel channel = m_ctxt.createChannel (name);
                m_ctxt.pendIO (PENDIO_TIMEOUT);
                cc = new CachedChannel (channel);
                cachedChannels.put (name, cc);
           }

            cc.updateReferenceTime();
            return cc;
        }


        /* Runs through list of cached channels, destroying those that have
           lingered long enough.
        */
        synchronized public void destroyDecrepitChannels ()
        {
            long since = System.currentTimeMillis() - CHANNEL_LINGER_MILLIS;

            Iterator cci = cachedChannels.values().iterator();
            while (cci.hasNext())
            {
                CachedChannel cc = (CachedChannel)cci.next();
                if (cc.isNotReferencedSince (since))
                {
                    cci.remove();
                    try
                    {
                        cc.destroyChannel();
                        cc = null;
                    }
                    catch (Exception e)
                    {
                        m_err.log (e);
                    } 
                }
            }
        }
    }


    private ChannelCache channelCache = new ChannelCache();


    

    DpCaI_impl(_PersistentDaObject da, org.omg.PortableServer.POA poa)
    {
        m_da = da;      
        m_orb = m_da.m_orb; // Make access to orb easy.
        m_poa = poa;        // Portable Object Adapter, not used atow

        // Get Err issuance singleton, and log init complete
        m_err = Err.getInstance();

        calendar.set (1990, Calendar.JANUARY, 0, 0, 0);
        epics_tzero = calendar.getTime();
    }
    
    public org.omg.PortableServer.POA
    _default_POA()
    {
        if(m_poa != null)
            return m_poa;
        else
            return super._default_POA();
    }
    
    //
    // IDL:dp.aida.slac.stanford.edu/dpCa/DpCaI/init:1.0
    //
    public void
    init()
        throws ServerInitialisationException
    {
        try 
        {
            // Get the JCALibrary instance.
            m_jca = JCALibrary.getInstance();
			
            // Create single threaded context with default configuration.
            m_ctxt = m_jca.createContext(JCALibrary.JNI_THREAD_SAFE);

            m_ctxt.printInfo();
        }
        catch ( Exception e )
        {
            throw (ServerInitialisationException) 
                m_err.log( new ServerInitialisationException(e.getMessage())); 
        }
        m_err.log("DpCaI servant initialization completed.");        
    }


    /* Silly utility function to convert DBR_XXX to DBR_TIME_XXX
     */
    static DBRType DBR_to_DBR_TIME (DBRType dbrt)
    {
        if (dbrt.isDOUBLE()) {
            return DBR_TIME_Double.TYPE;
        }
        else if (dbrt.isINT()) {
            return DBR_TIME_Int.TYPE;
        }
        else if (dbrt.isFLOAT()) {
            return DBR_TIME_Float.TYPE;
        }
        else if (dbrt.isSHORT()) {
            return DBR_TIME_Short.TYPE;
        }
        else if (dbrt.isENUM()) {
            return DBR_TIME_Enum.TYPE;
        }
        else if (dbrt.isBYTE()) {
            return DBR_TIME_Byte.TYPE;
        }
        else if (dbrt.isSTRING()) {
            return DBR_TIME_String.TYPE;
        }
        else return DBRType.UNKNOWN;
    }
    
    //
    // IDL:dp.aida.slac.stanford.edu/dpCa/DpCaI/get:1.0
    //
    /**
     * Returns CORBA Any representation of EPICS DBR_TIME_XXX 
     */
    public org.omg.CORBA.Any
    get(String query,
        String[] args)
        throws  UnableToGetDataException
    {
        try
        {
            String dateFormatSpec = "DATEFORM0";
            if ("DATEFORMAT".equals (args[0]))
                dateFormatSpec = args[1];

            MetaChannel mc = getMetaChannel (query);
            Channel ch = mc.channel;


            DBR dbr = ch.get (
                DBR_to_DBR_TIME (ch.getFieldType()), ch.getElementCount());
            m_ctxt.pendIO (PENDIO_TIMEOUT);

            // okay, now we've got a blob of data that we need to package up.
            // First the simple stuff.
            DaValue davalue = new DaValue();
            davalue.type = DaValue.Type.STRUCT;
            davalue.setName ("DBR_TIME");

            TimeStamp ts = ((TIME)dbr).getTimeStamp();
            String time = ts.toString();

            if ("EPICS".equals (dateFormatSpec))
            {
                time = (new Long (ts.secPastEpoch())).toString();
            }
            else
            {
                dateFormat.applyPattern (dateFormatSpec);
                calendar.setTimeInMillis (
                    epics_tzero.getTime() +
                    (ts.secPastEpoch() * 1000) +
                    (ts.nsec() / 1000000));
                time = dateFormat.format (calendar.getTime());
            }

            DaValue dv = new DaValue (time);
            dv.setName ("time");
            davalue.addElement (dv);

            dv = new DaValue (new Long (((STS)dbr).getStatus().getValue()));
            dv.setName ("status");
            davalue.addElement (dv);

            dv = new DaValue (new Long (((STS)dbr).getSeverity().getValue()));
            dv.setName ("severity");
            davalue.addElement (dv);

            
            if (dbr.isDOUBLE()) {
                dv = new DaValue (((DBR_Double)dbr).getDoubleValue());
            }
            else if (dbr.isINT()) {
                dv = new DaValue (((DBR_Int)dbr).getIntValue());
            }
            else if (dbr.isFLOAT()) {
                dv = new DaValue (((DBR_Float)dbr).getFloatValue());
            }
            else if (dbr.isSHORT()) {
                dv = new DaValue (((DBR_Short)dbr).getShortValue());
            }
            else if (dbr.isENUM()) {
                // transform index values to labels
                short[] idxs = ((DBR_Enum)dbr).getEnumValue();
                String[] strings = new String[idxs.length];
                for (int i = 0; i < strings.length; ++i)
                    strings[i] = mc.getEnumerationLabel (idxs[i]);
                
                dv = new DaValue (strings);
            }
            else if (dbr.isBYTE()) {
                dv = new DaValue (((DBR_Byte)dbr).getByteValue());
            }
            else { // assume isSTRING() --should get cast exception otherwise
                dv = new DaValue (((DBR_String)dbr).getStringValue());
            }
            
            dv.setName ("value");
            davalue.addElement (dv);

            return davalue.toAny();
        }
        
        catch (Exception e)
        {
            m_err.log (e);
            throw new UnableToGetDataException (query);
        }
    }
    
    
    //
    // IDL:dp.aida.slac.stanford.edu/dpCa/DpCaI/get_byte:1.0
    //
    public byte
    get_byte( String query,
              String[] args )
        throws  UnableToGetDataException
    {
        byte[] r = get_bytea( query, args );
        return r[0];
    }

    //
    // IDL:dp.aida.slac.stanford.edu/dpCa/DpCaI/get_char:1.0
    //
    public char
    get_char(String query,
             String[] args)
        throws  UnableToGetDataException
    {
        // Acquire char as DBRType.BYTE, convert to char, via String.
        return Byte.toString(get_byte( query, args )).charAt(0);
    }

    //
    // IDL:dp.aida.slac.stanford.edu/dpCa/DpCaI/get_wchar:1.0
    //
    public char
    get_wchar(String query,
              String[] args)
        throws  UnableToGetDataException
    {
        return get_char( query, args);
    }
		    
    //
    // IDL:dp.aida.slac.stanford.edu/dpCa/DpCaI/get_short:1.0
    //
    public short
    get_short( String query,
               String[] args )
        throws  UnableToGetDataException
    {
        short[] _r = get_shorta( query, args );
        return _r[0];        
    }
 
    //
    // IDL:dp.aida.slac.stanford.edu/dpCa/DpCaI/get_short:1.0
    //
    public int
    get_long( String query,
              String[] args )
        throws  UnableToGetDataException
    {
        int[] _r = get_longa( query, args );
        return _r[0];        
    }

    //
    // IDL:dp.aida.slac.stanford.edu/dpCa/DpCaI/get_boolean:1.0
    //
    public boolean
    get_boolean(String query,
                String[] args)
        throws  UnableToGetDataException
    {
        boolean[] _r = get_booleana( query, args );
        return _r[0];
    }

    //
    // IDL:dp.aida.slac.stanford.edu/dpCa/DpCaI/get_double:1.0
    //
    public double
    get_double(String query,
               String[] args)
        throws  UnableToGetDataException
    {
        double[] _r = get_doublea( query, args );
        return _r[0];
    }

    //
    // IDL:dp.aida.slac.stanford.edu/dpCa/DpCaI/get_float:1.0
    //
    public float
    get_float(String query,
              String[] args)
        throws  UnableToGetDataException
    {
        float[] _r = get_floata( query, args );
        return _r[0];
    }

    //
    // IDL:dp.aida.slac.stanford.edu/dpCa/DpCaI/get_string:1.0
    //
    public String
    get_string(String query,
               String[] args)
        throws  UnableToGetDataException
    {
        String[] _r = get_stringa( query, args );
        return _r[0];
    }

    //
    // IDL:dp.aida.slac.stanford.edu/dpCa/DpCaI/get_wstring:1.0
    //
    public String
    get_wstring(String query,
                String[] args)
        throws  UnableToGetDataException
    {
        return get_string(query, args);
    }

    //
    // IDL:dp.aida.slac.stanford.edu/dpCa/DpCaI/get_bytea:1.0
    //
    public byte[]
    get_bytea( String query,
               String[] args)
        throws  UnableToGetDataException
    {
        byte[] r={0};
        try
        {
            parseArgs(args);
            Channel ch = getChannel(query);
            int n = ch.getElementCount();
            BYTE dbr = (BYTE)ch.get( DBRType.BYTE, n );
            m_ctxt.pendIO( PENDIO_TIMEOUT );
            r = dbr.getByteValue();
        } 
        catch (Exception e)
        {
            log( e, query);
        }

        return r;
    }

    //
    // IDL:dp.aida.slac.stanford.edu/dpCa/DpCaI/get_chara:1.0
    //
    public char[]
    get_chara(String query,
              String[] args)
        throws  UnableToGetDataException
    {
        // Get byte[], convert to char[] via CharBuffer of a String of bytes.
        byte[] bytea = get_bytea( query, args );
        CharBuffer cb = CharBuffer.allocate(bytea.length);
        cb.put(bytea.toString());
        return cb.array();
    }


    //
    // IDL:dp.aida.slac.stanford.edu/dpCa/DpCaI/get_chara:1.0
    //
    public char[]
    get_wchara(String query,
               String[] args)
        throws  UnableToGetDataException
    {
        return get_chara( query, args );
    }

    //
    // IDL:dp.aida.slac.stanford.edu/dpCa/DpCaI/get_short:1.0
    //
    public short[]
    get_shorta( String query,
                String[] args )
        throws  UnableToGetDataException
    {
        short[] _r={0};                                // Return var
        try
        {
            parseArgs(args);
            Channel ch = getChannel(query);
            int n = ch.getElementCount();
            SHORT dbr = (SHORT)ch.get( DBRType.SHORT, n );
            m_ctxt.pendIO( PENDIO_TIMEOUT );
            _r = dbr.getShortValue();
        } 
        catch (Exception e)
        {
            log( e, query);
        }
        return _r;        
    }

    //
    // IDL:dp.aida.slac.stanford.edu/dpCa/DpCaI/get_longa:1.0
    //
    public int[]
    get_longa( String query,
               String[] args)
        throws  UnableToGetDataException
    {
        int[] _r={0};
        try
        {
            parseArgs(args);
            Channel ch = getChannel(query);
            int n = ch.getElementCount();
            INT dbr = (INT)ch.get( DBRType.INT, n );
            m_ctxt.pendIO( PENDIO_TIMEOUT );
            _r = dbr.getIntValue();
        } 
        catch (Exception e)
        {
            log( e, query);
        }
        return _r;
    }

    //
    // IDL:dp.aida.slac.stanford.edu/dpCa/DpCaI/get_booleana:1.0
    //
    public boolean[]
    get_booleana(String query,
                 String[] args)
        throws  UnableToGetDataException
    {
        // TODO: Is getting an int and casting to boolean really the right
        // thing to do here? Is there a CA channel boolean type?
        boolean[] _r={true};
        try
        {
            parseArgs(args);
            Channel ch = getChannel(query);
            int n = ch.getElementCount();
            INT dbr = (INT)ch.get( DBRType.INT, n );
            m_ctxt.pendIO( PENDIO_TIMEOUT );
            int[] rt = dbr.getIntValue();
            _r = new boolean[ n ]; 
            for (int i = 0; i < n ; i++)
                _r[i] = rt[i] == 0 ? false : true;            
        }
        catch (Exception e)
        {
            log( e, query);
        }
        return _r;
    }

    //
    // IDL:dp.aida.slac.stanford.edu/dpCa/DpCaI/get_doublea:1.0
    //
    public double[]
    get_doublea( String query,
                 String[] args )
        throws  UnableToGetDataException
    {
        double[] _r = {0.0};                   // Return var
		        
        // TODO: is there a difference between a waveform record and a 
        // record that has an element count of more > 1. Ie, is this 
        // adequate for getting waveform records?
        try
        {
            parseArgs(args);
            Channel ch = getChannel(query);
            int n = ch.getElementCount();
            DOUBLE dbr = (DOUBLE)ch.get( DBRType.DOUBLE, n );
            _r = dbr.getDoubleValue();
            m_ctxt.pendIO( PENDIO_TIMEOUT );
        } 
        catch (Exception e)
        {
            log( e, query);
        }
        return _r;
    }


    //
    // IDL:dp.aida.slac.stanford.edu/dpCa/DpCaI/get_floata:1.0
    //
    public float[]
    get_floata( String query,
                String[] args)
        throws  UnableToGetDataException
    {
        float[] _r = {0.0F};                   // Return var
        try
        {
            parseArgs(args);
            Channel ch = getChannel(query);
            int n = ch.getElementCount();
            FLOAT dbr = (FLOAT)ch.get( DBRType.FLOAT, n );
            _r = dbr.getFloatValue();
            m_ctxt.pendIO( PENDIO_TIMEOUT );
        } 
        catch (Exception e)
        {
            log( e, query );
        }
        return _r;
    }

    //
    // IDL:dp.aida.slac.stanford.edu/dpCa/DpCaI/get_stringa:1.0
    //
    public String[]
    get_stringa(String query,
                String[] args)
        throws  UnableToGetDataException
    {
        String[] _r={""};
        try
        {
            parseArgs(args);
            Channel ch = getChannel(query);
            int n = ch.getElementCount();
            STRING dbr = (STRING)ch.get( DBRType.STRING, n );
            m_ctxt.pendIO( PENDIO_TIMEOUT );
            _r = dbr.getStringValue();
        } 
        catch (Exception e)
        {
            log( e, query );
        }
        return _r;
    }


    /**
     * Acquires access to a JCA Channel for a given EPICS Channel Name.
     * @throws IllegalArgumentException query is invalid, may be not an
     * instance//attribute pair?
     */
    protected MetaChannel
    getMetaChannel( String query )
        throws IllegalArgumentException, CAException, TimeoutException
    {
        try
        {
            return channelCache.getMetaChannel (queryToChannelName (query));
        }
        // Err.log doesn't yet examine cause and issue that too,
        // so log it here.
        catch ( CAException e )
        {
            m_err.log( e, query );
            throw e;
        }
        catch ( TimeoutException e )
        {
            m_err.log( e, query );
            throw e;
        }
    }


    /**
     * Acquires access to a JCA Channel for a given EPICS Channel Name.
     * @throws IllegalArgumentException query is invalid, may be not an
     * instance//attribute pair?
     */
    protected Channel
    getChannel( String query )
        throws IllegalArgumentException, CAException, TimeoutException
    {
        return (getMetaChannel (query)).channel;
    }


    //
    // IDL:dp.aida.slac.stanford.edu/dpCa/DpCaI/set:1.0
    //
    public void set (
        String query,
        String[] args, 
        org.omg.CORBA.AnyHolder value)
        throws  UnableToSetDataException
    {
        try
        {
            Channel ch = getChannel (query);
            DaValue dv = new DaValue (value.value);

            // can't assume that CA server supports data type conversion
            DBRType type = ch.getFieldType();

            if (type.isDOUBLE())
            {
                ch.put (dv.getAsDoubles());
            }
            else if (type.isINT())
            {
                ch.put (dv.getAsInts());
            }
            else if (type.isFLOAT())
            {
                ch.put (dv.getAsFloats());
            }
            else if (type.isSHORT())
            {
                ch.put (dv.getAsShorts());
            }
            else if (type.isBYTE())
            {
                ch.put (dv.getAsBytes());
            }
            else if (type.isSTRING())
            {
                ch.put (dv.getAsStrings());
            }
            else if (type.isENUM())
            {
                // try to get the contents as enum indices, otherwise strings
                try {
                    ch.put (dv.getAsShorts());
                }
                catch (NumberFormatException e) {
                    ch.put (dv.getAsStrings());
                }
            }
            else
            {
                throw new UnsupportedOperationException (
                    "Unsupported data type");
            }

            m_ctxt.flushIO();
        }
        catch (Exception e)
        {
            throw (UnableToSetDataException)
                m_err.log (new UnableToSetDataException (e.getMessage()));
        }
    }
		    
    //
    // IDL:dp.aida.slac.stanford.edu/dpCa/DpCaI/startMonitor:1.0
    //
    public void
    startMonitor(String name)
        throws  MonitorStartupException
    {
        // TODO: later
    }
		    
    //
    // IDL:dp.aida.slac.stanford.edu/dpCa/DpCaI/stopMonitor:1.0
    //
    public void
    stopMonitor(String name)
        throws  MonitorShutdownException
    {
        // TODO: later
    }
		    
    //
    // IDL:dp.aida.slac.stanford.edu/dpCa/DpCaI/status:1.0
    //
    public int
    status()
    {
        // TODO: implement
        int _r = 0;
        return _r;
    }
		    
    //
    // IDL:dp.aida.slac.stanford.edu/dpCa/DpCaI/shutdown:1.0
    //
    public void
    shutdown()
    {
        // TODO: implement
    }
		 
		    
    /*
    ** PRIVATE METHOD DEFINITIONS
    */

    /**
     * Converts an Aida query string, of the form <instance>//<attribute>
     * to an EPICS Channel Name, of the form <PVname>.<fieldname>, by
     * simply replacing the "//" with ".".
     * 
     * @param String query Aida query string
     * @return EPICS Channel Name
     */
    private String
    queryToChannelName( String query )
    {
        int iSep = query.lastIndexOf(AQSToken.SEPARATOR);
        if ( iSep <2 )
            throw ((IllegalArgumentException) 
                   m_err.log(new IllegalArgumentException("Invalid name"+query)));
        return query.substring(0,iSep) + "." + query.substring(iSep+2);
    }

    /**
     * Examines the "parameters" passed from the client (those
     * things given by DaOBject.setParam()).
     *
     * Most DpCa get methods do not recognize any params, so throw
     * exception if one is given.
     * @throws IllegalArgumentException an argument/parameter was
     * given, where none is recognized.
     */
    private void parseArgs( String[] args )
        throws IllegalArgumentException
    {

        // nArgs is the effective number of of parameters. The AIDA
        // CORBA API results in at least 1 arg always, because the AidaObject
        // API does not define versions of each API method with a no-args arg,
        // so AIDA must supply at least 1 args arg, but args[0] to "null". 
        int nArgs = ( (args[0].compareTo("null")==0) ? 0 : args.length );

        // No parameters are recognized.
        if ( nArgs > 0 ) 
            throw (IllegalArgumentException) 
                // FUDGE: Should get servre name from property
                m_err.log(new IllegalArgumentException(
                              "Unrecognized parameter: "+
                              "No args are recognized by DpCa"));
    }

    /**
     * Issue message to error log and throw standard exception
     * @throws UnableToGetDataException all get methods throw this exception on error.
     */
    private void 
    log( Exception e, String query )
        throws UnableToGetDataException
    {
        // Before issuing error and throwing general
        // exception, try to clean up a little.
        try
        {
            m_ctxt.flushIO();
        }
        catch ( Exception ex )
        {
            m_err.log( ex );
        }

        // Now issue error.
        throw (UnableToGetDataException) 
            m_err.log( new UnableToGetDataException(query), 
                       "caused by: " + e.toString());
    }

}

