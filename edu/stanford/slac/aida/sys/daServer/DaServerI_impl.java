// **********************************************************************
//
// Generated by the ORBacus IDL to Java Translator
//
// Copyright (c) 2001
// IONA Technologies, Inc.
// Waltham, MA, USA
//
// All Rights Reserved
//
// Mods: 
//
//
// **********************************************************************

// Version: 4.1.0

package edu.stanford.slac.aida.sys.daServer;

import java.util.*;	                            // for StringTokenizer
import org.omg.CORBA.*;
import org.omg.PortableServer.*;                  
import edu.stanford.slac.except.*;              // General (checked) Exceptions
import edu.stanford.slac.err.*;                 // Error message issuance 
import edu.stanford.slac.aida.lib.util.common.*;  // Aida utilities.

//
// IDL:sys.aida.slac.stanford.edu/daServer/DaServerI:1.0
//

/**
 * Defines the primary AIDA client API. This class defines the
 * primary methods utilized by AIDA clients for synchronous data
 * access operations. 
 *
 * <p> <code>DaServerI_impl</code> implements the IDL interface
 * <code>DaServerI</code>.  <code>DaServerI</code> is an aidaObject
 * interface (generated from aidaObject.idl by Makefile by sed
 * substitution. </p>
 *
 * @author Greg White, Oct-2001
 * @version 28-Sep-2006, Bob Hall (rdh): Added args parameter to set method.
 * @version 20-Sep-2006, Bob Hall (rdh): Implemented set method.
 * @version 16-Sep-2004, Greg White (greg): Convert for Err singleton re-write.
 * @version Greg White, Sep-2004: Added exception handling.
 * @version 13-Nov-2002, Ron MacKenzie Change import of except from
 * aida to package except.
 * @version George McIntyre, July-2002: Newlabour prototype.
 *
 */
public class DaServerI_impl extends DaServerIPOA
{

	static Err err_;                    // Error message issuance API
	private POA poa_;                   // Portable Object Adaptor
	private _PersistentDaObject m_da;   // 
	private static int stat = 0;        // 0 when server is just started,
	// 1 after 1st call to status(). 

	/** 
	 * Server lookup cache This is the list of queries that have
	 * already been looked up.  It employs an optimistic lookup
	 * invalidation policy which tries to access the server first then
	 * if it fails replaces the cached entry with a newly looked up
	 * one.
	 * 
	 * The cache is contructed with instance attribute pairs as the
	 * key.  The value is the aidaObjectRef.  
	 * 
	 * TODO: Invalidate cache when a query which was found turned out
	 * to have bad or no-longer-valid data.
	 */
	private Hashtable m_cache = new Hashtable();

	public
	DaServerI_impl(_PersistentDaObject da)
	{
		m_da = da;
		poa_ = m_da.m_childPersistentPOA;
		err_ = Err.getInstance();        // Get error issuance reference
	}
	     
	public
	DaServerI_impl(_PersistentDaObject da, POA poa)
	{
		m_da = da;
		poa_ = poa;
		err_ = Err.getInstance();        // Get error issuance reference
	}
	     
	public POA
	_default_POA()
	{
		if(poa_ != null)
			return poa_;
		else
			return super._default_POA();
	}
	     
	//
	// IDL:sys.aida.slac.stanford.edu/daServer/DaServerI/init:1.0
	//
	/**
	 * Initializes a DaServer servant. Presently this method performs
	 * no operations. In fact, I think (greg) as yet it's never called.
	 */
	public void
	init()
		throws ServerInitialisationException
	{
		System.out.println("Initialising DaServer");
	}

	// Debug
	private void
	DOut(String returnType, String theTarget, String[] theArgs)
	{
		System.out.print("DaServer: " + returnType + " get" + 
				 ((returnType.compareTo("Any")==0) ? 
				  "" : 
				  ("_"+returnType)) + 
				 "(query='" + theTarget + "', args[");
		for (int i=0; i < theArgs.length ; i++)
			System.out.print(i + "='" + theArgs[i] + 
					 (((i+1)<theArgs.length) ? "', " : "'"));
		System.out.println("])");
		return;
	}
	     
	//
	// IDL:sys.aida.slac.stanford.edu/daServer/DaServerI/get:1.0
	//
	/**
	 * Gets AIDA accessible data given a query string (and possible paramters),
	 * where the returned data type is defined by the data provider (usually 
	 * because the data type is either unknown a-prori, or is structured). 
	 */
	public Any get(String query, String[] args) 
		throws UnableToGetDataException
	{
		try
		{
			// Parse and compile the query string
			_DaReference r = new _DaReference(query, m_da, args, m_cache);

			/**
			 * TODO: Place local server trap here and implement your
			 * server classes.  This can be done in all of the get*
			 * methods below.
			 */
			/*	    if ( r.instance.equalsIgnoreCase("DALOCALSERVER_1") )
				    return (DaLocalServer_1.getAny(r));
				    else if ( r.instance.equalsIgnoreCase("DALOCALSERVER_2") )
				    return (DaLocalServer_2.getAny(r));
				    else if ( r.instance.equalsIgnoreCase("DALOCALSERVER_3") )
				    return (DaLocalServer_3.getAny(r));
			*/	    
	    
			return (r.getAny());
		}
		catch (Exception ex)
		{
			throw (UnableToGetDataException) 
				err_.log(new UnableToGetDataException(query+printArgs(args)));
		}
	}
	     
	//
	// IDL:sys.aida.slac.stanford.edu/daServer/DaServerI/get_byte:1.0
	//
	/**
	 * Gets AIDA accessible data given a query string (and possible paramters),
	 * where the data type is byte.
	 */
	public byte
	get_byte(String query,
		 String[] args)
		throws UnableToGetDataException
	{
		/**
		 * Try/catch needed around _DaReference constructor call
		 * since that may throw UndefinedNameException, and this
		 * method may only throw UnableToGetDataException
		 */
		try
		{
			// Parse and compile the query string
			_DaReference r = new _DaReference(query, m_da, args, m_cache);  
			return r.get_byte();
		}
		catch (Exception ex)
		{
			throw (UnableToGetDataException) 
				err_.log(new UnableToGetDataException(query+printArgs(args)));
		}
	}
	     
	//
	// IDL:sys.aida.slac.stanford.edu/daServer/DaServerI/get_short:1.0
	//
	/**
	 * Gets AIDA accessible data given a query string (and possible paramters),
	 * where the data type is short.
	 */
	public short
	get_short(String query,
		  String[] args)
		throws UnableToGetDataException
	{
		try
		{
			// Parse and compile the query string
			_DaReference r = new _DaReference(query, m_da, args, m_cache); 
			return r.get_short();
		}
		catch (Exception ex)
		{
			throw (UnableToGetDataException) 
				err_.log(new UnableToGetDataException( query+printArgs(args) ));
		}
	}
	     
	//
	// IDL:sys.aida.slac.stanford.edu/daServer/DaServerI/get_long:1.0
	//
	/**
	 * Gets AIDA accessible data given a query string (and possible paramters),
	 * where the data type is long.
	 */
	public int
	get_long(String query,
		 String[] args)
		throws UnableToGetDataException
	{
		try
		{
			// Parse and compile the query string
			_DaReference r = new _DaReference(query, m_da, args, m_cache); 
			return (int)r.get_long();
		}
		catch (Exception ex)
		{
			throw (UnableToGetDataException) 
				err_.log(new UnableToGetDataException( query+printArgs(args) ));
		}
	}
	     
	//
	// IDL:sys.aida.slac.stanford.edu/daServer/DaServerI/get_boolean:1.0
	//
	/**
	 * Gets AIDA accessible data given a query string (and possible paramters),
	 * where the data type is boolean.
	 */
	public boolean
	get_boolean(String query,
		    String[] args)
		throws UnableToGetDataException
	{
		try
		{
			// Parse and compile the query string
			_DaReference r = new _DaReference(query, m_da, args, m_cache); 
			return r.get_boolean();
		}
		catch (Exception ex)
		{
			throw (UnableToGetDataException) 
				err_.log(new UnableToGetDataException( query+printArgs(args) ));
		}
	}
	     
	//
	// IDL:sys.aida.slac.stanford.edu/daServer/DaServerI/get_double:1.0
	//
	/**
	 * Gets AIDA accessible data given a query string (and possible paramters),
	 * where the data type is double.
	 */
	public double
	get_double(String query,
		   String[] args)
		throws UnableToGetDataException
	{
		try
		{
			// Parse and compile the query string
			_DaReference r = new _DaReference(query, m_da, args, m_cache);
			return r.get_double();
		}
		catch (Exception ex)
		{
			throw (UnableToGetDataException) 
				err_.log(new UnableToGetDataException( query+printArgs(args) ));
		}
	}
	     
	//
	// IDL:sys.aida.slac.stanford.edu/daServer/DaServerI/get_float:1.0
	//
	/**
	 * Gets AIDA accessible data given a query string (and possible paramters),
	 * where the data type is float.
	 */
	public float
	get_float(String query,
		  String[] args)
		throws UnableToGetDataException
	{
		try
		{
			// Parse and compile the query string
			_DaReference r = new _DaReference(query, m_da, args, m_cache);   
			return r.get_float();
		}
		catch (Exception ex)
		{
			throw (UnableToGetDataException) 
				err_.log(new UnableToGetDataException(query+printArgs(args)));
		}
	}
	     
	//
	// IDL:sys.aida.slac.stanford.edu/daServer/DaServerI/get_string:1.0
	//
	/**
	 * Gets AIDA accessible data given a query string (and possible paramters),
	 * where the data type is string.
	 */
	public String
	get_string(String query,
		   String[] args)
		throws UnableToGetDataException
	{
		try
		{
			// Parse and compile the query string
			_DaReference r = new _DaReference(query, m_da, args, m_cache);   
			return r.get_string();
		}
		catch (Exception ex)
		{
			throw (UnableToGetDataException) 
				err_.log(new UnableToGetDataException(query+printArgs(args)));
		}
	}
	     
	//
	// IDL:sys.aida.slac.stanford.edu/daServer/DaServerI/get_char:1.0
	//
	/**
	 * Gets AIDA accessible data given a query string (and possible paramters),
	 * where the data type is char.
	 */
	public char
	get_char(String query,
		 String[] args)
		throws UnableToGetDataException
	{
		try
		{
			// Parse and compile the query string
			_DaReference r = new _DaReference(query, m_da, args, m_cache);   
			return r.get_char();
		}
		catch (Exception ex)
		{
			throw (UnableToGetDataException) 
				err_.log(new UnableToGetDataException(query+printArgs(args)));
		}
	}
	     
	//
	// IDL:sys.aida.slac.stanford.edu/daServer/DaServerI/get_wstring:1.0
	//
	/**
	 * Gets AIDA accessible data given a query string (and possible paramters),
	 * where the data type is wide-string.
	 */
	public String
	get_wstring(String query,
		    String[] args)
		throws UnableToGetDataException
	{
		try
		{
			// Parse and compile the query string
			_DaReference r = new _DaReference(query, m_da, args, m_cache);   
			return r.get_string();
		}
		catch (Exception ex)
		{
			throw (UnableToGetDataException) 
				err_.log(new UnableToGetDataException(query+printArgs(args)));
		}
	}
	     
	//
	// IDL:sys.aida.slac.stanford.edu/daServer/DaServerI/get_wchar:1.0
	//
	/**
	 * Gets AIDA accessible data given a query string (and possible paramters),
	 * where the data type is wide-string.
	 */
	public char
	get_wchar(String query,
		  String[] args)
		throws UnableToGetDataException
	{
		try
		{
			// Parse and compile the query string
			_DaReference r = new _DaReference(query, m_da, args, m_cache);   
			return (char)r.get_char();
		}
		catch (Exception ex)
		{
			throw (UnableToGetDataException) 
				err_.log(new UnableToGetDataException(query+printArgs(args)));
		}
	}
	     
	//
	// IDL:sys.aida.slac.stanford.edu/daServer/DaServerI/get_bytea:1.0
	//
	/**
	 * Gets AIDA accessible data given a query string (and possible paramters),
	 * where the data type is array of byte.
	 */
	public byte[]
	get_bytea(String query,
		  String[] args)
		throws UnableToGetDataException
	{
		try
		{
			// Parse and compile the query string
			_DaReference r = new _DaReference(query, m_da, args, m_cache);   
			return r.get_bytea();
		}
		catch (Exception ex)
		{
			throw (UnableToGetDataException) 
				err_.log(new UnableToGetDataException(query+printArgs(args)));
		}
	}
	     
	//
	// IDL:sys.aida.slac.stanford.edu/daServer/DaServerI/get_shorta:1.0
	//
	/**
	 * Gets AIDA accessible data given a query string (and possible paramters),
	 * where the data type is array of short.
	 */
	public short[]
	get_shorta(String query,
		   String[] args)
		throws UnableToGetDataException
	{
		try
		{
			// Parse and compile the query string
			_DaReference r = new _DaReference(query, m_da, args, m_cache);   
			return r.get_shorta();
		}
		catch (Exception ex)
		{
			throw (UnableToGetDataException) 
				err_.log(new UnableToGetDataException(query+printArgs(args)));
		}
	}
	     
	//
	// IDL:sys.aida.slac.stanford.edu/daServer/DaServerI/get_longa:1.0
	//
	/**
	 * Gets AIDA accessible data given a query string (and possible paramters),
	 * where the data type is array of long.
	 */
	public int[]
	get_longa(String query,
		  String[] args)
		throws UnableToGetDataException
	{
		try
		{
			// Parse and compile the query string
			_DaReference r = new _DaReference(query, m_da, args, m_cache);   
			return r.get_longa();
		}
		catch (Exception ex)
		{
			throw (UnableToGetDataException) 
				err_.log(new UnableToGetDataException(query+printArgs(args)));
		}
	}
	     
	//
	// IDL:sys.aida.slac.stanford.edu/daServer/DaServerI/get_booleana:1.0
	//
	/**
	 * Gets AIDA accessible data given a query string (and possible paramters),
	 * where the data type is array of boolean.
	 */
	public boolean[]
	get_booleana(String query,
		     String[] args)
		throws UnableToGetDataException
	{
		try
		{
			// Parse and compile the query string
			_DaReference r = new _DaReference(query, m_da, args, m_cache);   
			return r.get_booleana();
		}
		catch (Exception ex)
		{
			throw (UnableToGetDataException) 
				err_.log(new UnableToGetDataException(query+printArgs(args)));
		}
	}
	     
	//
	// IDL:sys.aida.slac.stanford.edu/daServer/DaServerI/get_doublea:1.0
	//
	/**
	 * Gets AIDA accessible data given a query string (and possible paramters),
	 * where the data type is array of double.
	 */
	public double[]
	get_doublea(String query,
		    String[] args)
		throws UnableToGetDataException
	{
		try
		{
			_DaReference r = new _DaReference(query, m_da, args, m_cache);   
			return r.get_doublea();
		}
		catch (Exception ex)
		{
			throw (UnableToGetDataException) 
				err_.log(new UnableToGetDataException(query+printArgs(args)));
		}
	}
	     
	//
	// IDL:sys.aida.slac.stanford.edu/daServer/DaServerI/get_floata:1.0
	//
	/**
	 * Gets AIDA accessible data given a query string (and possible paramters),
	 * where the data type is array of float.
	 */
	public float[]
	get_floata(String query,
		   String[] args)
		throws UnableToGetDataException
	{
		try
		{
			_DaReference r = new _DaReference(query, m_da, args, m_cache);   
			return r.get_floata();
		}
		catch (Exception ex)
		{
			throw (UnableToGetDataException) 
				err_.log(new UnableToGetDataException(query+printArgs(args)));
		}
	}
	     
	//
	// IDL:sys.aida.slac.stanford.edu/daServer/DaServerI/get_stringa:1.0
	//
	/**
	 * Gets AIDA accessible data given a query string (and possible paramters),
	 * where the data type is array of string.
	 */
	public String[]
	get_stringa(String query,
		    String[] args)
		throws UnableToGetDataException
	{
		try
		{
			// Parse and compile the query string
			_DaReference r = new _DaReference(query, m_da, args, m_cache);   
			return r.get_stringa();
		}
		catch (Exception ex)
		{
			throw (UnableToGetDataException) 
				err_.log(new UnableToGetDataException(query+printArgs(args)));
		}
	}
	     
	//
	// IDL:sys.aida.slac.stanford.edu/daServer/DaServerI/get_chara:1.0
	//
	/**
	 * Gets AIDA accessible data given a query string (and possible paramters),
	 * where the data type is array of char.
	 */
	public char[]
	get_chara(String query,
		  String[] args)
		throws UnableToGetDataException
	{
		try
		{
			// Parse and compile the query string
			_DaReference r = new _DaReference(query, m_da, args, m_cache);   
			return r.get_chara();
		}
		catch (Exception ex)
		{
			throw (UnableToGetDataException) 
				err_.log(new UnableToGetDataException(query+printArgs(args)));
		}
	}
	     
	//
	// IDL:sys.aida.slac.stanford.edu/daServer/DaServerI/get_wchara:1.0
	//
	/**
	 * Gets AIDA accessible data given a query string (and possible paramters),
	 * where the data type is array of wide-char.
	 */
	public char[]
	get_wchara(String query,
		   String[] args)
		throws UnableToGetDataException
	{
		try
		{
			// Parse and compile the query string
			_DaReference r = new _DaReference(query, m_da, args, m_cache);   
			return r.get_chara();
		}
		catch (Exception ex)
		{
			throw (UnableToGetDataException) 
				err_.log(new UnableToGetDataException(query+printArgs(args)));
		}
	}
	     
	//
	// IDL:sys.aida.slac.stanford.edu/daServer/DaServerI/set:1.0
	//
	/**
	 * Sets value or values of AIDA accessible data, given a query specifcation
	 * of that data, and CORBA Any.
	 */
	public void
	set(String query,
            String[] args, 
	    org.omg.CORBA.AnyHolder value)
		throws UnableToSetDataException
	{
                try
                {
                    _DaReference r = new _DaReference(query, m_da, args, m_cache);

		    Any a = r.set(value);

                    return;
                }
                catch (Exception ex)
                {
                    throw (UnableToSetDataException)
                        err_.log(new UnableToSetDataException(query));
                }
	}
	     
	//
	// IDL:sys.aida.slac.stanford.edu/daServer/DaServerI/startMonitor:1.0
	//
	/**
	 * Initates monitoring for an AIDA accessible data item for asynchronous 
	 * event handling. NOT YET IMPLEMENTED
	 */
	public void
	startMonitor(String name)
		throws MonitorStartupException
	{
		return;
	}
	     
	//
	// IDL:sys.aida.slac.stanford.edu/daServer/DaServerI/stopMonitor:1.0
	//
	/**
	 * Terminates monitoring for an AIDA accessible data item for asynchronous 
	 * event handling. NOT YET IMPLEMENTED
	 */
	public void
	stopMonitor(String name)
		throws MonitorShutdownException
	{
		return;
	}
	     
	//
	// IDL:sys.aida.slac.stanford.edu/daServer/DaServerI/status:1.0
	//
	public int
	status()
	{
		if (stat == 0)
			return stat++;
		else
			return stat;
	}
	     
	//
	// IDL:sys.aida.slac.stanford.edu/daServer/DaServerI/shutdown:1.0
	//
	/** 
	 * Performs clean shutdown of DaServer.
	 */
	public void
	shutdown()
	{
		m_da.m_orb.shutdown(false);
	}

	/**
	 * Converts the String array args to a single String suitable for printing.
	 * @param args The parameters client program supplied to a DaObject method
	 * @return A single String, formed by concatenation of String[] args.
	 */
	private String printArgs( String[] args )
	{
		String s = ""; // Ret var: args as a single string.

		// nArgs is the effective number of of parameters. The AIDA
		// CORBA API results in at least 1 arg always, because the
		// AidaObject API does not define versions of each API method
		// with no args arg, so CORBA must supply the args arg. The
		// Aida convention is that in this case args[0] is set to teh
		// String "null". That is args[0]==null means no parameters
		// were given to the AIDA API method.
		int nArgs = ( (args[0].compareTo("null")==0) ? 0 : args.length );
		for (int i=0; i<nArgs; i++)
			s = s+" "+args[i];
		return s;
	}
}
