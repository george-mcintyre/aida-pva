/**
 * SLC Server implementation
 */
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <descrip.h>              /*  for definition of $DESCRIPTOR  */

#include "aida_server_helper.h"
#include "json.h"

#include <cvtdef.h>               /*  CVT$K_*, CVT$M_*  */
#include <cvtmsg.h>               /*  CVT$_NORMAL  */
#include <cvt$routines.h>         /*  CVT$CONVERT_FLOAT  */

#include "dpslc_jni.h"     /* Generated by javah */
#include "slc_macros.h"    /* vmsstat_t, int2u, int4u, etc. */
#include "msg_proto.h"     /* for standalone_init */
#include "sysutil_proto.h" /* for cvt_vms_to_ieee_flt */

#include "slc_server.h"

/**
 * Initialise the service
 * @param env to be used to throw exceptions using aidaThrow() and aidaNonOsExceptionThrow()
 * @throws ServerInitialisationException if the service fails to initialise
 */
void aidaServiceInit(JNIEnv* env)
{
	vmsstat_t status;

	if (!SUCCESS(status = DB_INIT())) {
		aidaThrow(env, status, SERVER_INITIALISATION_EXCEPTION, "initialising SLC Service");
	} else {
		printf("Aida SLC Database Service Initialised\n");
	}
}

/**
 * Get channel configuration
 * @param env to be used to throw exceptions using aidaThrow() and aidaNonOsExceptionThrow()
 * @param channelName
 * @param forGetter true to return config for getter, false for setter
 * @return the channel config.  Leave empty if you don't have any specific configuration overrides
 */
Config aidaChannelConfig(JNIEnv* env, const char* channelName, short forGetter)
{
	DEFAULT_CONFIG_REQUEST
}

/**
 * Get a boolean.  In fact this is implemented by getting a short and returning true if it is 0 and false otherwise
 *
 * @param env to be used to throw exceptions using aidaThrow() and aidaNonOsExceptionThrow()
 * @param uri the uri
 * @param arguments the arguments
 * @return the boolean
 */
int aidaRequestBoolean(JNIEnv* env, const char* uri, Arguments arguments)
{
	short int val = 0;
	vmsstat_t status = JNI_DBGETSHORT(uri, &val);

	if (!SUCCESS(status)) {
		aidaThrow(env, status, UNABLE_TO_GET_DATA_EXCEPTION, "getting Short");
	}

	return val == 0;
}

/**
 * Get a byte
 *
 * @param env to be used to throw exceptions using aidaThrow() and aidaNonOsExceptionThrow()
 * @param uri the uri
 * @param arguments the arguments
 * @return the byte
 */
char aidaRequestByte(JNIEnv* env, const char* uri, Arguments arguments)
{
	unsigned char val = 0;
	vmsstat_t status = JNI_DBGETBYTE(uri, &val);

	if (!SUCCESS(status)) {
		aidaThrow(env, status, UNABLE_TO_GET_DATA_EXCEPTION, "getting Byte");
	}

	return (char)val;
}

/**
 * Get a short
 *
 * @param uri the uri
 * @param env to be used to throw exceptions using aidaThrow() and aidaNonOsExceptionThrow()
 * @param arguments the arguments
 * @return the short
 */
short aidaRequestShort(JNIEnv* env, const char* uri, Arguments arguments)
{
	short int val = 0;
	vmsstat_t status = JNI_DBGETSHORT(uri, &val);

	if (!SUCCESS(status)) {
		aidaThrow(env, status, UNABLE_TO_GET_DATA_EXCEPTION, "getting Short");
	}

	return val;
}

/**
 * Get a integer
 *
 * @param env to be used to throw exceptions using aidaThrow() and aidaNonOsExceptionThrow()
 * @param uri the uri
 * @param arguments the arguments
 * @return the integer
 */
int aidaRequestInteger(JNIEnv* env, const char* uri, Arguments arguments)
{
	int val = 0;
	vmsstat_t status = JNI_DBGETINT(uri, &val);

	if (!SUCCESS(status)) {
		aidaThrow(env, status, UNABLE_TO_GET_DATA_EXCEPTION, "getting Short");
	}

	return val;
}

/**
 * Get a long.  In fact this is implemented by getting an integer and then converting the return value to a long
 *
 * @param env to be used to throw exceptions using aidaThrow() and aidaNonOsExceptionThrow()
 * @param uri the uri
 * @param arguments the arguments
 * @return the long
 */
long aidaRequestLong(JNIEnv* env, const char* uri, Arguments arguments)
{
	int val = 0;
	vmsstat_t status = JNI_DBGETINT(uri, &val);

	if (!SUCCESS(status)) {
		aidaThrow(env, status, UNABLE_TO_GET_DATA_EXCEPTION, "getting Short");
	}

	return val;
}

/**
 * Get a float
 *
 * @param env to be used to throw exceptions using aidaThrow() and aidaNonOsExceptionThrow()
 * @param uri the uri
 * @param arguments the arguments
 * @return the float
 */
float aidaRequestFloat(JNIEnv* env, const char* uri, Arguments arguments)
{
	float val = 0.0f; /* Returned in ieee format */
	vmsstat_t status = JNI_DBGETFLOAT(uri, &val);

	if (!SUCCESS(status)) {
		aidaThrow(env, status, UNABLE_TO_GET_DATA_EXCEPTION, "getting Float");
	}

	return val;
}

/**
 * Get a double.  In fact this is implemented by getting a float and converting the return to a double
 *
 * @param env to be used to throw exceptions using aidaThrow() and aidaNonOsExceptionThrow()
 * @param uri the uri
 * @param arguments the arguments
 * @return the double
 */
double aidaRequestDouble(JNIEnv* env, const char* uri, Arguments arguments)
{
	float val = 0.0f; /* Returned in ieee format */
	vmsstat_t status = JNI_DBGETFLOAT(uri, &val);

	if (!SUCCESS(status)) {
		aidaThrow(env, status, UNABLE_TO_GET_DATA_EXCEPTION, "getting Float");
	}

	return val;
}

/**
 * Get a string.  Allocate memory for string and it will be freed for you by framework
 *
 * @param env to be used to throw exceptions using aidaThrow() and aidaNonOsExceptionThrow()
 * @param uri the uri
 * @param arguments the arguments
 * @return the string
 */
char* aidaRequestString(JNIEnv* env, const char* uri, Arguments arguments)
{
	char* val = NULL;
	vmsstat_t status = JNI_DBGETSTRING(uri, &val);

	if (!SUCCESS(status)) {
		aidaThrow(env, status, UNABLE_TO_GET_DATA_EXCEPTION, "getting String");
	}

	return val;
}

/**
 * Get a boolean array
 *
 * @param env to be used to throw exceptions using aidaThrow() and aidaNonOsExceptionThrow()
 * @param uri the uri
 * @param arguments the arguments
 * @return the boolean array
 */
Array aidaRequestBooleanArray(JNIEnv* env, const char* uri, Arguments arguments)
{
	UNSUPPORTED_ARRAY_REQUEST
}

/**
 * Get a byte array
 *
 * @param env to be used to throw exceptions using aidaThrow() and aidaNonOsExceptionThrow()
 * @param uri the uri
 * @param arguments the arguments
 * @return the byte array
 */
Array aidaRequestByteArray(JNIEnv* env, const char* uri, Arguments arguments)
{
	Array byteArray;
	byteArray.count = 0;
	byteArray.items = NULL;

	vmsstat_t status = JNI_DBGETBYTEA(uri, (unsigned char**)(&byteArray.items));

	if (!SUCCESS(status)) {
		aidaThrow(env, status, UNABLE_TO_GET_DATA_EXCEPTION, "getting Byte Array");
	}

	byteArray.count = (int)strlen(byteArray.items);
	return byteArray;
}

/**
 * Get a short array
 *
 * @param env to be used to throw exceptions using aidaThrow() and aidaNonOsExceptionThrow()
 * @param uri the uri
 * @param arguments the arguments
 * @return the short array
 */
Array aidaRequestShortArray(JNIEnv* env, const char* uri, Arguments arguments)
{
	Array shortArray;
	shortArray.count = 0;
	shortArray.items = NULL;

	vmsstat_t status = JNI_DBGETSHORTA(uri, (short**)(&shortArray.items));

	if (!SUCCESS(status)) {
		aidaThrow(env, status, UNABLE_TO_GET_DATA_EXCEPTION, "getting Short Array");
	}

	shortArray.count = (int)*((short*)shortArray.items) + 1;
	return shortArray;
}

/**
 * Get a integer array
 *
 * @param env to be used to throw exceptions using aidaThrow() and aidaNonOsExceptionThrow()
 * @param uri the uri
 * @param arguments the arguments
 * @return the integer array
 */
Array aidaRequestIntegerArray(JNIEnv* env, const char* uri, Arguments arguments)
{
	Array integerArray;
	integerArray.count = 0;
	integerArray.items = NULL;

	vmsstat_t status = JNI_DBGETINTA(uri, (int**)(&integerArray.items));

	if (!SUCCESS(status)) {
		aidaThrow(env, status, UNABLE_TO_GET_DATA_EXCEPTION, "getting Int Array");
	}

	integerArray.count = (int)*((int*)integerArray.items) + 1;
	return integerArray;
}

/**
 * Get a long array
 *
 * @param env to be used to throw exceptions using aidaThrow() and aidaNonOsExceptionThrow()
 * @param uri the uri
 * @param arguments the arguments
 * @return the long array
 */
Array aidaRequestLongArray(JNIEnv* env, const char* uri, Arguments arguments)
{
	UNSUPPORTED_ARRAY_REQUEST
}

/**
 * Get a float array
 *
 * @param env to be used to throw exceptions using aidaThrow() and aidaNonOsExceptionThrow()
 * @param uri the uri
 * @param arguments the arguments
 * @return the float array
 */
Array aidaRequestFloatArray(JNIEnv* env, const char* uri, Arguments arguments)
{
	Array floatArray;
	floatArray.count = 0;
	floatArray.items = NULL;

	vmsstat_t status = JNI_DBGETFLOATA(uri, (float**)(&floatArray.items));

	if (!SUCCESS(status)) {
		aidaThrow(env, status, UNABLE_TO_GET_DATA_EXCEPTION, "getting Float Array");
	}

	floatArray.count = (int)*((float*)floatArray.items) + 1;
	return floatArray;
}

/**
 * Get a double array
 *
 * @param env to be used to throw exceptions using aidaThrow() and aidaNonOsExceptionThrow()
 * @param uri the uri
 * @param arguments the arguments
 * @return the double array
 */
Array aidaRequestDoubleArray(JNIEnv* env, const char* uri, Arguments arguments)
{
	UNSUPPORTED_ARRAY_REQUEST
}

/**
 * Get a string array
 *
 * @param env to be used to throw exceptions using aidaThrow() and aidaNonOsExceptionThrow()
 * @param uri the uri
 * @param arguments the arguments
 * @return the string array
 */
StringArray aidaRequestStringArray(JNIEnv* env, const char* uri, Arguments arguments)
{
	UNSUPPORTED_STRING_ARRAY_REQUEST
}

/**
 * Get a table of data
 *
 * @param env to be used to throw exceptions using aidaThrow() and aidaNonOsExceptionThrow()
 * @param uri the uri
 * @param arguments the arguments
 * @return the table
 */
Table aidaRequestTable(JNIEnv* env, const char* uri, Arguments arguments)
{
	// Get type parameter
	Argument  argument = getArgument(arguments, "TABLE_TYPE");
	if ( !argument.name ) {
		UNSUPPORTED_TABLE_REQUEST
	}

	char *specifiedType = argument.value;

	// Make a table
	Table table;
	memset(&table, 0, sizeof(table));
	table.columnCount = 8;

	table = tableCreate(env, 1, 8);
	CHECK_EXCEPTION(table)

	// Add column based on TYPE
	if (strcasecmp(specifiedType, "FLOAT") == 0) {
		float value = aidaRequestFloat(env, uri, arguments);
		CHECK_EXCEPTION(table)
		tableAddSingleRowFloatColumn(env, &table, value);
		CHECK_EXCEPTION(table)
	} else if (strcasecmp(specifiedType, "DOUBLE") == 0) {
		double value = aidaRequestDouble(env, uri, arguments);
		CHECK_EXCEPTION(table)
		tableAddSingleRowDoubleColumn(env, &table, value);
		CHECK_EXCEPTION(table)
	} else if (strcasecmp(specifiedType, "BYTE") == 0) {
		char value = aidaRequestByte(env, uri, arguments);
		CHECK_EXCEPTION(table)
		tableAddSingleRowByteColumn(env, &table, value);
		CHECK_EXCEPTION(table)
	} else if (strcasecmp(specifiedType, "SHORT") == 0) {
		short value = aidaRequestShort(env, uri, arguments);
		CHECK_EXCEPTION(table)
		tableAddSingleRowShortColumn(env, &table, value);
		CHECK_EXCEPTION(table)
	} else if (strcasecmp(specifiedType, "INTEGER") == 0) {
		int value = aidaRequestInteger(env, uri, arguments);
		CHECK_EXCEPTION(table)
		tableAddSingleRowIntegerColumn(env, &table, value);
		CHECK_EXCEPTION(table)
	} else if (strcasecmp(specifiedType, "LONG") == 0) {
		long value = aidaRequestLong(env, uri, arguments);
		CHECK_EXCEPTION(table)
		tableAddSingleRowLongColumn(env, &table, value);
		CHECK_EXCEPTION(table)
	} else if (strcasecmp(specifiedType, "BOOLEAN") == 0) {
		int value = aidaRequestBoolean(env, uri, arguments);
		CHECK_EXCEPTION(table)
		tableAddSingleRowBooleanColumn(env, &table, value);
		CHECK_EXCEPTION(table)
	} else if (strcasecmp(specifiedType, "STRING") == 0) {
		char* value = aidaRequestString(env, uri, arguments);
		CHECK_EXCEPTION(table)
		tableAddSingleRowStringColumn(env, &table, value);
		CHECK_EXCEPTION(table)

	} else if(strcasecmp(specifiedType, "FLOAT_ARRAY") == 0 ) {
		Array value = aidaRequestFloatArray(env, uri, arguments);
		CHECK_EXCEPTION(table)
		tableAddColumn(env, &table, AIDA_FLOAT_ARRAY_TYPE, value.items);
		CHECK_EXCEPTION(table)
	} else if (strcasecmp(specifiedType, "DOUBLE_ARRAY") == 0) {
		Array value = aidaRequestDoubleArray(env, uri, arguments);
		CHECK_EXCEPTION(table)
		tableAddColumn(env, &table, AIDA_DOUBLE_ARRAY_TYPE, value.items);
		CHECK_EXCEPTION(table)
	} else if (strcasecmp(specifiedType, "BYTE_ARRAY") == 0) {
		Array value = aidaRequestByteArray(env, uri, arguments);
		CHECK_EXCEPTION(table)
		tableAddColumn(env, &table, AIDA_BYTE_ARRAY_TYPE, value.items);
		CHECK_EXCEPTION(table)
	} else if (strcasecmp(specifiedType, "SHORT_ARRAY") == 0) {
		Array value = aidaRequestShortArray(env, uri, arguments);
		CHECK_EXCEPTION(table)
		tableAddColumn(env, &table, AIDA_SHORT_ARRAY_TYPE, value.items);
		CHECK_EXCEPTION(table)
	} else if (strcasecmp(specifiedType, "INTEGER_ARRAY") == 0) {
		Array value = aidaRequestIntegerArray(env, uri, arguments);
		CHECK_EXCEPTION(table)
		tableAddColumn(env, &table, AIDA_INTEGER_ARRAY_TYPE, value.items);
		CHECK_EXCEPTION(table)
	} else if (strcasecmp(specifiedType, "LONG_ARRAY") == 0) {
		Array value = aidaRequestLongArray(env, uri, arguments);
		CHECK_EXCEPTION(table)
		tableAddColumn(env, &table, AIDA_LONG_ARRAY_TYPE, value.items);
		CHECK_EXCEPTION(table)
	} else if (strcasecmp(specifiedType, "BOOLEAN_ARRAY") == 0) {
		Array value = aidaRequestBooleanArray(env, uri, arguments);
		CHECK_EXCEPTION(table)
		tableAddColumn(env, &table, AIDA_BOOLEAN_ARRAY_TYPE, value.items);
		CHECK_EXCEPTION(table)
	}

	// Return the table
	return table;
}

/**
 * Set a value
 *
 * @param env to be used to throw exceptions using aidaThrow() and aidaNonOsExceptionThrow()
 * @param uri the uri
 * @param arguments the arguments
 * @param value to set
 * @return the table
 */
void aidaSetValue(JNIEnv* env, const char* uri, Arguments arguments, Value value)
{
	float *data;
	int length;
	if ( avscanf(env, &arguments, &value, "%fa", "value", &data, &length) ) {
		return;
	}

	vmsstat_t status = JNI_DBSETFLOAT(uri, data, length);
	free(data);

	if (!SUCCESS(status)) {
		aidaThrowNonOsException(env, UNABLE_TO_SET_DATA_EXCEPTION, "Setting floats");
	}
}

/**
 * Set a value and return a table as a response
 *
 * @param env to be used to throw exceptions using aidaThrow() and aidaNonOsExceptionThrow()
 * @param uri the uri
 * @param arguments the arguments
 * @param value to set
 * @return a table
 */
Table aidaSetValueWithResponse(JNIEnv* env, const char* uri, Arguments arguments, Value value)
{
	UNSUPPORTED_TABLE_REQUEST
}

