/**
 * SLC Server implementation
 */
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <descrip.h>              /*  for definition of $DESCRIPTOR  */

#include "aida_server_helper.h"
#include "json.h"

#include <cvtdef.h>               /*  CVT$K_*, CVT$M_*  */
#include <cvtmsg.h>               /*  CVT$_NORMAL  */
#include <cvt$routines.h>         /*  CVT$CONVERT_FLOAT  */

#include "dpslc_jni.h"     /* Generated by javah */
#include "slc_macros.h"    /* vmsstat_t, int2u, int4u, etc. */
#include "msg_proto.h"     /* for standalone_init */
#include "sysutil_proto.h" /* for cvt_vms_to_ieee_flt */

#include "slc_server.h"

/**
 * Initialise the service
 * @param env to be used to throw exceptions using aidaThrow() and aidaNonOsExceptionThrow()
 * @throws ServerInitialisationException if the service fails to initialise
 */
void aidaServiceInit(JNIEnv* env)
{
	vmsstat_t status;

	if (!SUCCESS(status = DB_INIT())) {
		aidaThrow(env, status, SERVER_INITIALISATION_EXCEPTION, "initialising SLC Service");
	} else {
		printf("Aida SLC Database Service Initialised\n");
	}
}

/**
 * Get channel configuration
 * @param env to be used to throw exceptions using aidaThrow() and aidaNonOsExceptionThrow()
 * @param channelName
 * @param forGetter true to return config for getter, false for setter
 * @return the channel config.  Leave empty if you don't have any specific configuration overrides
 */
Config aidaChannelConfig(JNIEnv* env, const char* channelName, short forGetter)
{
	DEFAULT_CONFIG_REQUEST
}

/**
 * Get a boolean.  In fact this is implemented by getting a short and returning true if it is 0 and false otherwise
 *
 * @param env to be used to throw exceptions using aidaThrow() and aidaNonOsExceptionThrow()
 * @param uri the uri
 * @param arguments the arguments
 * @return the boolean
 */
int aidaRequestBoolean(JNIEnv* env, const char* uri, Arguments arguments)
{
	int val = 0;
	TO_SLAC_NAME
	vmsstat_t status = JNI_DBGETINT(slcName, &val);

	if (!SUCCESS(status)) {
		aidaThrow(env, status, UNABLE_TO_GET_DATA_EXCEPTION, "getting SLC db boolean device data");
	}

	// Return logical
	return val != 0;
}

/**
 * Get a byte
 *
 * @param env to be used to throw exceptions using aidaThrow() and aidaNonOsExceptionThrow()
 * @param uri the uri
 * @param arguments the arguments
 * @return the byte
 */
char aidaRequestByte(JNIEnv* env, const char* uri, Arguments arguments)
{
	unsigned char val = 0;
	TO_SLAC_NAME
	vmsstat_t status = JNI_DBGETBYTE(slcName, &val);

	if (!SUCCESS(status)) {
		aidaThrow(env, status, UNABLE_TO_GET_DATA_EXCEPTION, "getting SLC db byte device data");
	}

	return (char)val;
}

/**
 * Get a short
 *
 * @param uri the uri
 * @param env to be used to throw exceptions using aidaThrow() and aidaNonOsExceptionThrow()
 * @param arguments the arguments
 * @return the short
 */
short aidaRequestShort(JNIEnv* env, const char* uri, Arguments arguments)
{
	short int val = 0;
	TO_SLAC_NAME
	vmsstat_t status = JNI_DBGETSHORT(slcName, &val);

	if (!SUCCESS(status)) {
		aidaThrow(env, status, UNABLE_TO_GET_DATA_EXCEPTION, "getting SLC db short device data");
	}

	return val;
}

/**
 * Get a integer
 *
 * @param env to be used to throw exceptions using aidaThrow() and aidaNonOsExceptionThrow()
 * @param uri the uri
 * @param arguments the arguments
 * @return the integer
 */
int aidaRequestInteger(JNIEnv* env, const char* uri, Arguments arguments)
{
	int val = 0;
	TO_SLAC_NAME
	vmsstat_t status = JNI_DBGETINT(slcName, &val);

	if (!SUCCESS(status)) {
		aidaThrow(env, status, UNABLE_TO_GET_DATA_EXCEPTION, "getting SLC db integer device data");
	}

	return val;
}

/**
 * Get a long.  In fact this is implemented by getting an integer and then converting the return value to a long
 *
 * @param env to be used to throw exceptions using aidaThrow() and aidaNonOsExceptionThrow()
 * @param uri the uri
 * @param arguments the arguments
 * @return the long
 */
long aidaRequestLong(JNIEnv* env, const char* uri, Arguments arguments)
{
	int val = 0;
	TO_SLAC_NAME
	vmsstat_t status = JNI_DBGETINT(slcName, &val);

	if (!SUCCESS(status)) {
		aidaThrow(env, status, UNABLE_TO_GET_DATA_EXCEPTION, "getting SLC db long device data");
	}

	return val;
}

/**
 * Get a float
 *
 * @param env to be used to throw exceptions using aidaThrow() and aidaNonOsExceptionThrow()
 * @param uri the uri
 * @param arguments the arguments
 * @return the float
 */
float aidaRequestFloat(JNIEnv* env, const char* uri, Arguments arguments)
{
	float val = 0.0f; /* Returned in ieee format */
	TO_SLAC_NAME
	vmsstat_t status = JNI_DBGETFLOAT(slcName, &val);

	if (!SUCCESS(status)) {
		aidaThrow(env, status, UNABLE_TO_GET_DATA_EXCEPTION, "getting SLC db floating point device data");
	}

	return val;
}

/**
 * Get a double.  In fact this is implemented by getting a float and converting the return to a double
 *
 * @param env to be used to throw exceptions using aidaThrow() and aidaNonOsExceptionThrow()
 * @param uri the uri
 * @param arguments the arguments
 * @return the double
 */
double aidaRequestDouble(JNIEnv* env, const char* uri, Arguments arguments)
{
	float val = 0.0f; /* Returned in ieee format */
	TO_SLAC_NAME
	vmsstat_t status = JNI_DBGETFLOAT(slcName, &val);

	if (!SUCCESS(status)) {
		aidaThrow(env, status, UNABLE_TO_GET_DATA_EXCEPTION, "getting SLC db double device data");
	}

	return val;
}

/**
 * Get a string.  Allocate memory for string and it will be freed for you by framework
 *
 * @param env to be used to throw exceptions using aidaThrow() and aidaNonOsExceptionThrow()
 * @param uri the uri
 * @param arguments the arguments
 * @return the string
 */
char* aidaRequestString(JNIEnv* env, const char* uri, Arguments arguments)
{
	char* val = NULL;
	TO_SLAC_NAME
	vmsstat_t status = JNI_DBGETSTRING(slcName, &val);

	if (!SUCCESS(status)) {
		aidaThrow(env, status, UNABLE_TO_GET_DATA_EXCEPTION, "getting SLC db string device data");
	}

	return val;
}

/**
 * Get a boolean array
 *
 * @param env to be used to throw exceptions using aidaThrow() and aidaNonOsExceptionThrow()
 * @param uri the uri
 * @param arguments the arguments
 * @return the boolean array
 */
Array aidaRequestBooleanArray(JNIEnv* env, const char* uri, Arguments arguments)
{
	Array booleanArray;
	booleanArray.count = 0;
	booleanArray.items = NULL;

	TO_SLAC_NAME
	vmsstat_t status = JNI_DBGETINTA(slcName, (int**)(&booleanArray.items));

	if (!SUCCESS(status)) {
		aidaThrow(env, status, UNABLE_TO_GET_DATA_EXCEPTION, "getting SLC db boolean array device data");
	}

	// First item is the count
	booleanArray.count = *((int*)booleanArray.items);

	// update values to contain booleans instead of integers
	for (int i = 0; i < booleanArray.count; i++) {
		((int*)booleanArray.items)[i] = ((int*)booleanArray.items)[i] != 0;
	}
	return booleanArray;
}

/**
 * Get a byte array
 *
 * @param env to be used to throw exceptions using aidaThrow() and aidaNonOsExceptionThrow()
 * @param uri the uri
 * @param arguments the arguments
 * @return the byte array
 */
Array aidaRequestByteArray(JNIEnv* env, const char* uri, Arguments arguments)
{
	Array byteArray;
	byteArray.count = 0;
	byteArray.items = NULL;

	TO_SLAC_NAME
	vmsstat_t status = JNI_DBGETBYTEA(slcName, (unsigned char**)(&byteArray.items));

	if (!SUCCESS(status)) {
		aidaThrow(env, status, UNABLE_TO_GET_DATA_EXCEPTION, "getting SLC db byte array device data");
	}

	byteArray.count = (int)strlen(byteArray.items);
	return byteArray;
}

/**
 * Get a short array
 *
 * @param env to be used to throw exceptions using aidaThrow() and aidaNonOsExceptionThrow()
 * @param uri the uri
 * @param arguments the arguments
 * @return the short array
 */
Array aidaRequestShortArray(JNIEnv* env, const char* uri, Arguments arguments)
{
	Array shortArray;
	shortArray.count = 0;
	shortArray.items = NULL;

	TO_SLAC_NAME
	vmsstat_t status = JNI_DBGETSHORTA(slcName, (short**)(&shortArray.items));

	if (!SUCCESS(status)) {
		aidaThrow(env, status, UNABLE_TO_GET_DATA_EXCEPTION, "getting SLC db short array device data");
	}

	// First item is the count
	shortArray.count = (int)*((short*)shortArray.items);

	// Copy shorts to new short array and free up returned short array
	short* shortData = calloc(shortArray.count, sizeof(short));
	for (int i = 0; i < shortArray.count; i++) {
		shortData[i] = ((short*)shortArray.items)[i + 1];
	}
	free(shortArray.items);
	shortArray.items = shortData;
	return shortArray;
}

/**
 * Get a integer array
 *
 * @param env to be used to throw exceptions using aidaThrow() and aidaNonOsExceptionThrow()
 * @param uri the uri
 * @param arguments the arguments
 * @return the integer array
 */
Array aidaRequestIntegerArray(JNIEnv* env, const char* uri, Arguments arguments)
{
	Array integerArray;
	integerArray.count = 0;
	integerArray.items = NULL;

	TO_SLAC_NAME
	vmsstat_t status = JNI_DBGETINTA(slcName, (int**)(&integerArray.items));

	if (!SUCCESS(status)) {
		aidaThrow(env, status, UNABLE_TO_GET_DATA_EXCEPTION, "getting SLC db int array device data");
	}

	// First item is the count
	integerArray.count = *((int*)integerArray.items);

	// Copy integers to new integer array and free up returned integer array
	int* integerData = calloc(integerArray.count, sizeof(int));
	for (int i = 0; i < integerArray.count; i++) {
		integerData[i] = ((int*)integerArray.items)[i + 1];
	}
	free(integerArray.items);
	integerArray.items = integerData;
	return integerArray;
}

/**
 * Get a long array
 *
 * @param env to be used to throw exceptions using aidaThrow() and aidaNonOsExceptionThrow()
 * @param uri the uri
 * @param arguments the arguments
 * @return the long array
 */
Array aidaRequestLongArray(JNIEnv* env, const char* uri, Arguments arguments)
{
	Array longArray;
	longArray.count = 0;
	longArray.items = NULL;

	TO_SLAC_NAME
	vmsstat_t status = JNI_DBGETINTA(slcName, (int**)(&longArray.items));

	if (!SUCCESS(status)) {
		aidaThrow(env, status, UNABLE_TO_GET_DATA_EXCEPTION, "getting SLC db long array device data");
	}

	// First item is the count
	longArray.count = *((int*)longArray.items);

	// Copy integers to new long array and free up returned integer array
	long* longData = calloc(longArray.count, sizeof(long));
	for (int i = 0; i < longArray.count; i++) {
		longData[i] = (long)((int*)longArray.items)[i + 1];
	}
	free(longArray.items);
	longArray.items = longData;
	return longArray;
}

/**
 * Get a float array
 *
 * @param env to be used to throw exceptions using aidaThrow() and aidaNonOsExceptionThrow()
 * @param uri the uri
 * @param arguments the arguments
 * @return the float array
 */
Array aidaRequestFloatArray(JNIEnv* env, const char* uri, Arguments arguments)
{
	Array floatArray;
	floatArray.count = 0;
	floatArray.items = NULL;

	TO_SLAC_NAME
	vmsstat_t status = JNI_DBGETFLOATA(slcName, (float**)(&floatArray.items));

	if (!SUCCESS(status)) {
		aidaThrow(env, status, UNABLE_TO_GET_DATA_EXCEPTION, "getting SLC db float array device data");
	}

	// First item is the count
	floatArray.count = (int)*((float*)floatArray.items);

	// Copy floats to new float array and free up returned float array
	float* floatData = calloc(floatArray.count, sizeof(float));
	for (int i = 0; i < floatArray.count; i++) {
		floatData[i] = ((float*)floatArray.items)[i + 1];
	}
	free(floatArray.items);
	floatArray.items = floatData;
	return floatArray;
}

/**
 * Get a double array
 *
 * @param env to be used to throw exceptions using aidaThrow() and aidaNonOsExceptionThrow()
 * @param uri the uri
 * @param arguments the arguments
 * @return the double array
 */
Array aidaRequestDoubleArray(JNIEnv* env, const char* uri, Arguments arguments)
{
	Array doubleArray;
	doubleArray.count = 0;
	doubleArray.items = NULL;

	TO_SLAC_NAME
	vmsstat_t status = JNI_DBGETFLOATA(slcName, (float**)(&doubleArray.items));

	if (!SUCCESS(status)) {
		aidaThrow(env, status, UNABLE_TO_GET_DATA_EXCEPTION, "getting SLC db double array device data");
	}

	// First item is the count
	doubleArray.count = (int)*((float*)doubleArray.items);

	// Copy floats to new double array and free up returned float array
	double* doubleData = calloc(doubleArray.count, sizeof(double));
	for (int i = 0; i < doubleArray.count; i++) {
		doubleData[i] = ((float*)doubleArray.items)[i + 1];
	}
	free(doubleArray.items);
	doubleArray.items = doubleData;

	return doubleArray;
}

/**
 * Get a string array:
 *
 * If the primary is ASTS and the pseudo-secondary is
 * either CTRL, STAT, VSTA,
 * parse the text, color, and flag fields from the string
 * returned by aidaRequestString().  The text, color, and flag
 * substrings are then returned in an array
 *
 * @param env to be used to throw exceptions using aidaThrow() and aidaNonOsExceptionThrow()
 * @param uri the uri
 * @param arguments the arguments
 * @return the string array
 */
#define TEXT_SUBSTRING 8
#define COLOR_SUBSTRING 8
#define FLAG_SUBSTRING 1
StringArray aidaRequestStringArray(JNIEnv* env, const char* uri, Arguments arguments)
{
	const char * secondary = secondaryFromUri(uri);
	// If not ASTS and CTRL, STAT or VSTA
	if (!startsWith(uri, "ASTS") || (strcasecmp(secondary, "CTRL") != 0 && strcasecmp(secondary, "STAT") != 0 && strcasecmp(secondary, "VSTA") != 0 )) {
		UNSUPPORTED_STRING_ARRAY_REQUEST
	}
	StringArray stringArray;
	stringArray.count = 0;

	char* colorString = aidaRequestString(env, uri, arguments);
	CHECK_EXCEPTION(stringArray)


	//	  The substring returned by aidaRequestString is 19
	//	  characters long and contains the text substring
	//	  in characters 0-7, the color substring in
	//	  characters 9-16, and the flag substring in
	//	  character position 18.

	stringArray.count = 3;
	stringArray.items = calloc(3, sizeof(char*));
	((char**)(stringArray.items))[0] = malloc(TEXT_SUBSTRING + 1); // text substring
	((char**)(stringArray.items))[1] = malloc(COLOR_SUBSTRING + 1); // color substring
	((char**)(stringArray.items))[2] = malloc(FLAG_SUBSTRING + 1); // flag

	memcpy(((char**)(stringArray.items))[0], colorString, TEXT_SUBSTRING);
	(((char**)(stringArray.items))[0])[TEXT_SUBSTRING] = 0x0;

	memcpy(((char**)(stringArray.items))[1], colorString + TEXT_SUBSTRING + 1, COLOR_SUBSTRING);
	(((char**)(stringArray.items))[1])[COLOR_SUBSTRING] = 0x0;

	memcpy(((char**)(stringArray.items))[2], colorString + TEXT_SUBSTRING + 1 + COLOR_SUBSTRING + 1, FLAG_SUBSTRING);
	(((char**)(stringArray.items))[2])[FLAG_SUBSTRING] = 0x0;

	free(colorString);

	return stringArray;
}

/**
 * Get a table of data
 *
 * @param env to be used to throw exceptions using aidaThrow() and aidaNonOsExceptionThrow()
 * @param uri the uri
 * @param arguments the arguments
 * @return the table
 */
Table aidaRequestTable(JNIEnv* env, const char* uri, Arguments arguments)
{
	// Get type parameter
	Argument argument = getArgument(arguments, "TABLE_TYPE");
	if (!argument.name) {
		UNSUPPORTED_TABLE_REQUEST
	}

	char* specifiedType = argument.value;

	// Make a table
	Table table;
	memset(&table, 0, sizeof(table));
	table.columnCount = 0;

	// Add column based on TYPE
	if (strcasecmp(specifiedType, "FLOAT") == 0) {
		float value = aidaRequestFloat(env, uri, arguments);
		CHECK_EXCEPTION(table)
		table = tableCreate(env, 1, 1);
		CHECK_EXCEPTION(table)
		tableAddSingleRowFloatColumn(env, &table, value);
		CHECK_EXCEPTION(table)
	} else if (strcasecmp(specifiedType, "DOUBLE") == 0) {
		double value = aidaRequestDouble(env, uri, arguments);
		CHECK_EXCEPTION(table)
		table = tableCreate(env, 1, 1);
		CHECK_EXCEPTION(table)
		tableAddSingleRowDoubleColumn(env, &table, value);
		CHECK_EXCEPTION(table)
	} else if (strcasecmp(specifiedType, "BYTE") == 0) {
		char value = aidaRequestByte(env, uri, arguments);
		CHECK_EXCEPTION(table)
		table = tableCreate(env, 1, 1);
		CHECK_EXCEPTION(table)
		tableAddSingleRowByteColumn(env, &table, value);
		CHECK_EXCEPTION(table)
	} else if (strcasecmp(specifiedType, "SHORT") == 0) {
		short value = aidaRequestShort(env, uri, arguments);
		CHECK_EXCEPTION(table)
		table = tableCreate(env, 1, 1);
		CHECK_EXCEPTION(table)
		tableAddSingleRowShortColumn(env, &table, value);
		CHECK_EXCEPTION(table)
	} else if (strcasecmp(specifiedType, "INTEGER") == 0) {
		int value = aidaRequestInteger(env, uri, arguments);
		CHECK_EXCEPTION(table)
		table = tableCreate(env, 1, 1);
		CHECK_EXCEPTION(table)
		tableAddSingleRowIntegerColumn(env, &table, value);
		CHECK_EXCEPTION(table)
	} else if (strcasecmp(specifiedType, "LONG") == 0) {
		long value = aidaRequestLong(env, uri, arguments);
		CHECK_EXCEPTION(table)
		table = tableCreate(env, 1, 1);
		CHECK_EXCEPTION(table)
		tableAddSingleRowLongColumn(env, &table, value);
		CHECK_EXCEPTION(table)
	} else if (strcasecmp(specifiedType, "BOOLEAN") == 0) {
		int value = aidaRequestBoolean(env, uri, arguments);
		CHECK_EXCEPTION(table)
		table = tableCreate(env, 1, 1);
		CHECK_EXCEPTION(table)
		tableAddSingleRowBooleanColumn(env, &table, value);
		CHECK_EXCEPTION(table)
	} else if (strcasecmp(specifiedType, "STRING") == 0) {
		char* value = aidaRequestString(env, uri, arguments);
		CHECK_EXCEPTION(table)
		table = tableCreate(env, 1, 1);
		CHECK_EXCEPTION(table)
		tableAddSingleRowStringColumn(env, &table, value);
		CHECK_EXCEPTION(table)

	} else if (strcasecmp(specifiedType, "FLOAT_ARRAY") == 0) {
		Array value = aidaRequestFloatArray(env, uri, arguments);
		CHECK_EXCEPTION(table)
		table = tableCreate(env, value.count, 1);
		CHECK_EXCEPTION(table)
		tableAddColumn(env, &table, AIDA_FLOAT_ARRAY_TYPE, value.items);
		CHECK_EXCEPTION(table)
	} else if (strcasecmp(specifiedType, "DOUBLE_ARRAY") == 0) {
		Array value = aidaRequestDoubleArray(env, uri, arguments);
		CHECK_EXCEPTION(table)
		table = tableCreate(env, value.count, 1);
		CHECK_EXCEPTION(table)
		tableAddColumn(env, &table, AIDA_DOUBLE_ARRAY_TYPE, value.items);
		CHECK_EXCEPTION(table)
	} else if (strcasecmp(specifiedType, "BYTE_ARRAY") == 0) {
		Array value = aidaRequestByteArray(env, uri, arguments);
		CHECK_EXCEPTION(table)
		table = tableCreate(env, value.count, 1);
		CHECK_EXCEPTION(table)
		tableAddColumn(env, &table, AIDA_BYTE_ARRAY_TYPE, value.items);
		CHECK_EXCEPTION(table)
	} else if (strcasecmp(specifiedType, "SHORT_ARRAY") == 0) {
		Array value = aidaRequestShortArray(env, uri, arguments);
		CHECK_EXCEPTION(table)
		table = tableCreate(env, value.count, 1);
		CHECK_EXCEPTION(table)
		tableAddColumn(env, &table, AIDA_SHORT_ARRAY_TYPE, value.items);
		CHECK_EXCEPTION(table)
	} else if (strcasecmp(specifiedType, "INTEGER_ARRAY") == 0) {
		Array value = aidaRequestIntegerArray(env, uri, arguments);
		CHECK_EXCEPTION(table)
		table = tableCreate(env, value.count, 1);
		CHECK_EXCEPTION(table)
		tableAddColumn(env, &table, AIDA_INTEGER_ARRAY_TYPE, value.items);
		CHECK_EXCEPTION(table)
	} else if (strcasecmp(specifiedType, "LONG_ARRAY") == 0) {
		Array value = aidaRequestLongArray(env, uri, arguments);
		CHECK_EXCEPTION(table)
		table = tableCreate(env, value.count, 1);
		CHECK_EXCEPTION(table)
		tableAddColumn(env, &table, AIDA_LONG_ARRAY_TYPE, value.items);
		CHECK_EXCEPTION(table)
	} else if (strcasecmp(specifiedType, "BOOLEAN_ARRAY") == 0) {
		Array value = aidaRequestBooleanArray(env, uri, arguments);
		CHECK_EXCEPTION(table)
		table = tableCreate(env, value.count, 1);
		CHECK_EXCEPTION(table)
		tableAddColumn(env, &table, AIDA_BOOLEAN_ARRAY_TYPE, value.items);
		CHECK_EXCEPTION(table)
	}

	// Return the table
	return table;
}

/**
 * Set a value
 *
 * @param env to be used to throw exceptions using aidaThrow() and aidaNonOsExceptionThrow()
 * @param uri the uri
 * @param arguments the arguments
 * @param value to set
 * @return the table
 */
void aidaSetValue(JNIEnv* env, const char* uri, Arguments arguments, Value value)
{
	if (!JNI_DBACCESSENABLED()) {
		aidaThrowNonOsException(env, UNABLE_TO_GET_DATA_EXCEPTION,
				"Aida access for SLC Database set operations are not currently enabled");
		return;
	}

	float* data;
	unsigned int length;
	if (avscanf(env, &arguments, &value, "%fa", "value", &data, &length)) {
		return;
	}

	TO_SLAC_NAME
	vmsstat_t status = JNI_DBSETFLOAT(slcName, data, (int)length);
	free(data);

	if (!SUCCESS(status)) {
		aidaThrowNonOsException(env, UNABLE_TO_SET_DATA_EXCEPTION, "setting SLC db float array device data");
	}
}

/**
 * Set a value and return a table as a response
 *
 * @param env to be used to throw exceptions using aidaThrow() and aidaNonOsExceptionThrow()
 * @param uri the uri
 * @param arguments the arguments
 * @param value to set
 * @return a table
 */
Table aidaSetValueWithResponse(JNIEnv* env, const char* uri, Arguments arguments, Value value)
{
	UNSUPPORTED_TABLE_REQUEST
}
