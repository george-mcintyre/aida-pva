/*
============================================================================== 
 
  Abs:  This contains the implementation of the AIDA Channel Archiver
        Data Provicer.  See the IDL file for more details.

  Name: dpChads_impl.cc

        See the IDL file for the method definitions.
        Right now, only this method has real code in it:
        CORBA::Any* dpChads::DpChadsI_impl::get()

  Proto: dpChads_impl.h (generated by the idl compiler).

  Rem: 
   This program is based on dpTestHist (the test History AIDA program).

   dpTestHist_impl is part of the Chads (Channel Archiver Data Source) Server.
   I (ronm) took the Orbacus Hello_impl.cpp and modified it to create
   the Chads class implementation.   I added Channel Archiver calls
   modeled after the code in Channel Archiver manager.list_values().
   The Manager list_values code is here:
   package/epics/vers3/R3.13.2/extensions/src/ChannelArchiver/Manager

   There were intermediate versions called Chads_impl and caHist_impl.

  Auth: 10-Mar-2003, Ron MacKenzie
  Rev:  DD-MMM-YYYY, Reviewer's Name (.NE. Author's Name)
 
---------------------------------------------------------------------------
 
  Mod:
      02-Feb-2011, Bob Hall
        Modified to support new FACET archiver system.  Also changed
        the location of the LCLS log file to be on the
        /nfs/slac/g/archiver disk.
      24-Mar-2010, Bob Hall
        Corrected user parameter "SPARCE" to correct spelling:
        "SPARSE".  Also changed to make the retrieval of sparsified
        data the default.
      17-Mar-2010, Bob Hall
        Added new DENSITY parameter for LCLS to allow retrieval
        from indexes for sparsified data.  Also increased the
        maximum number of subsystem indexes from 20 to 100. 
      03-Jan-2009, Bob Hall
        Modified to determine which indexes are needed without
        user specification.  Also modified to allow more flexible
        user specified start and end time formats (e.g., single
        digit months and days).
      11-Nov-2008, Bob Hall
        Modified to allow the new 2008 index. 
      02-Aug-2008, Bob Hall
        Added histData structure isdst field for each sample.
      28-Jul-2008, Bob Hall
        Added new INDEX parameter for LCLS to allow users to retrieve
        older archiver data by specifying an index.
      29-Aug-2007, Bob Hall
        Modified to return all values for a waveform.  As a result
        the histData structure count field was added for each sample. 
      28-Aug-2007, Bob Hall
        Modified the location of where to find the archiver index
        file for each subsystem to a subdirectory of /nfs/slac/g/cd_archvier.
      16-Aug-2007, Bob Hall
        Added histData structure pulseid field for each sample.
      18-Jul-2007, Bob Hall
        Temporary changed the location of where to find the archiver
        index file for each subsystem to a subdirectory of
        /nfs/slac/g/esd/archiver.
      27-Jun-2007, Bob Hall
        Modified the location of where to find the archiver index
        file for each subsystem to a subdirectory of /nfs/slac/g/cd_archvier.
      10-Mar-2007, Bob Hall
        Modified to process the new LCLS subsystem. 
      14-Aug-2006, Bob Hall
        Modified to allow hour start or end time specification to be
        a single digit.
      12-Jul-2006, Bob Hall
        Added histData structure unixtime field for each sample, which
        contains the sample timestamp in UNIX timestamp format (the
        number of seconds since midnight on Jan. 1, 1970). 
      10-Jul-2006, Bob Hall
        Changed to fix bug that was causing the server to crash due to
        having too many files open.  The problem was due to the DataReader
        object being not being deleted after each client request.  Therefore,
        the IndexFile object and DataReader object instantiation was moved
        from the constructor to the "get Any" method and the DataReader object
        is now deleted after each client request (and the IndexFile object
        close method is called).
      17-May-2005, Bob Hall
        Fixed DATEFORMAT comparison errors. 
      12-Nov-2004, Bob Hall
        Major modifications to retrieve data from the new EPICS 3.14.6
        Channel Archiver datafiles.  Previously this routine retrieved
        data from either the old EPICS 3.13 format datafiles or Oracle
        using the now obsolete LibIO API.
      17-Apr-2003, Ron MacKenzie
        Put error logging into local class so we can add metering there later.
        Add exception logging and throwing logic.
      30-Mar-2003, Ron MacKenzie
        Change environment variable from CHADS_USE_ORACLE_ARCHIVER to
        CHADS_USE_FILE_ARCHIVER, making Oracle the default if no env. varb
        is set.
           
============================================================================*/

#include "ArgParser.h"     // for CmdSrcString

// From EPICS base
#include "epicsVersion.h"

// From EPICS extension Tools
#include "AutoPtr.h"
#include "BinaryTree.h"
#include "RegularExpression.h"
#include "epicsTimeHelper.h"

// From Channel Archiver Storage directory
#include "SpreadsheetReader.h"
#include "ListIndex.h"
 
#include "ArchiveException.h"

#define DEBUG_TRACE

#include <stdio.h>
#include <time.h>

#include <sys/time.h>                   // for select in delay func
#include <OB/CORBA.h>
#include "err.h"
#include "except.h"
#include "chadsErrlog.h"                   // chads error logger.
#include <dpChads_impl.h>

#define NUM_SECONDS_BETWEEN_EPOCHS 631152000
#define EPICS_TIMESTAMP_LENGTH 19
#define NUM_DATE_TWO_DIGIT_TIMESTAMP_FIELDS 2
#define NUM_TIME_TWO_DIGIT_TIMESTAMP_FIELDS 3
#define YEAR_FIELD_LENGTH 4
#define DATEFORM0_LENGTH 20
#define NUM_MONTHS 12
#define MAX_NUM_SUBSYSTEM_INDEXES 100 
#define MAX_INDEX_FILEPATH_LEN 70
#define MAX_SUBSYSTEM_ARCHIVER_INDEXES_FILEPATH_LEN 70
#define MAX_TIMESTRING_LEN 19
#define MAX_BUFFER_LEN 132

#define AIDA_ARCHIVER_INDEXES_DIR "/nfs/slac/g/archiver/aida_indexes"
#define AIDA_ARCHIVER_INDEXES_FILENAME_SUFFIX "_indexes_info.txt"

#ifdef HAVE_STD_IOSTREAM
using namespace std;
#endif

// local func to wait some number of milliseconds.

void my_delay(long millisecs)
{
        struct timeval tval;
        tval.tv_sec = millisecs / 1000;
        millisecs -= tval.tv_sec * 1000;
        tval.tv_usec = millisecs * 1000;
        select(0, 0, 0, 0, &tval);
}

//
// Converts dateform0 timestamp string (dd-mmm-yyyy hh:mm:ss) to an 
// EPICS timestamp string (mm/dd/yyyy hh:mm:ss).
//
int convert_dateform0_to_epics_timestamp(char *dateform0_timestamp,
                                         char *epics_timestamp)
{
    int status;
    int num_converted;
    int converted_value;
    int found;
    int month_offset;

    char day[3];
    char in_month[4];
    char year[5];
    char hour[3];
    char minute[3];
    char second[3];

    char epics_date_time[EPICS_TIMESTAMP_LENGTH + 1];

    char months[][4] = {"Jan", "Feb", "Mar",
                        "Apr", "May", "Jun",
                        "Jul", "Aug", "Sep",
                        "Oct", "Nov", "Dec"};

    /* Logic begins.
    ---------------- */
    status = 1;

    /* First, validate the input dateform0 timestamp string.
    -------------------------------------------------------- */
    if (strlen(dateform0_timestamp) != DATEFORM0_LENGTH)
    {
        status = 0;
        return status;
    }

    strncpy(dateform0_timestamp, day, 2);
    day[2] = '\0';

    num_converted = sscanf(day, "%d", &converted_value);
    if (num_converted != 1)
    {
        status = 0;
        return status;
    }

    strncpy(dateform0_timestamp + 3, in_month, 3);
    in_month[3] = '\0';

    month_offset = 0;
    found = 0;
    while ((month_offset < NUM_MONTHS) && (!found))
    {
        if (strcmp(in_month, months[month_offset]) == 0)
        {
            found = 1;
        }
        else
        {
            month_offset++;
        }
    }

    if (!found)
    {
        status = 0;
        return status;
    }

    strncpy(dateform0_timestamp + 7, year, 4);
    year[4] = '\0';

    num_converted = sscanf(year, "%d", &converted_value);
    if (num_converted != 1)
    {
        status = 0;
        return status;
    }

    strncpy(dateform0_timestamp + 12, hour, 2);
    hour[2] = '\0';

    num_converted = sscanf(hour, "%d", &converted_value);
    if (num_converted != 1)
    {
        status = 0;
        return status;
    }

    strncpy(dateform0_timestamp + 15, minute, 2);
    minute[2] = '\0';

    num_converted = sscanf(minute, "%d", &converted_value);
    if (num_converted != 1)
    {
        status = 0;
        return status;
    }

    strncpy(dateform0_timestamp + 18, second, 2);
    second[2] = '\0';

    num_converted = sscanf(second, "%d", &converted_value);
    if (num_converted != 1)
    {
        status = 0;
        return status;
    }

    /* Finally, assemble the output EPICS timestamp from the
       month, day, year, hour, minute, and second subfields in
       the input DATEFORM0 timestamp.
    ---------------------------------------------------------- */
    sprintf(epics_date_time, "%02d", month_offset + 1);
    strcat(epics_date_time, "/");
    strcat(epics_date_time, day);
    strcat(epics_date_time, "/");
    strcat(epics_date_time, year);

    strcat(epics_date_time, " ");
    strcat(epics_date_time, hour);
    strcat(epics_date_time, ":");
    strcat(epics_date_time, minute);
    strcat(epics_date_time, ":");
    strcat(epics_date_time, second);

    strcpy(epics_timestamp, epics_date_time);

    return status;
}

//
// Converts an input field of one or two digits to an output
// two digit timestamp field.  This function is used to
// process a month, day, hour, minute, or second timestamp
// field that may have one or two digits.  If it has two
// digits, this routine also validates the timestamp field
// by checking to make sure it is not larger than the input
// high limit for the field.  If the input field has only
// one digit, the output field will have a leading zero.
// Besides the two digit output field, this routine also
// returns the number of input field digits (1 or 2).
//
int convert_to_two_digit_timestamp_field(char *input_field,
                                         int high_limit,
                                         int *num_input_field_chars,
                                         char *output_field)
{
    int status;
    int num_converted;
    int two_digit_value;

    char field_str[3];

    /* Logic begins.
    ---------------- */
    status = 1;

    /* Check to make sure that the first character in the
       input field is a digit.
    ----------------------------------------------------- */
    if (!isdigit(*input_field) )
    {
        status = 0;
        return status;
    }

    if (isdigit(*(input_field + 1)) )
    {
        /* The second character in the input field was also
           digit.  Simply copy the two digits in the input
           field to the output field.  Then check to make
           sure the number represented by the two digit
           field is not greater than the input hight limit
           for the field.  Finally, return a value that
           indicates that the input field had two digits.
        -------------------------------------------------- */
        field_str[0] = *input_field;
        field_str[1] = *(input_field + 1);
        field_str[2] = '\0';

        num_converted = sscanf(field_str, "%d", &two_digit_value);
        if (num_converted != 1)
        {
            status = 0;
            return status;
        }

        if (two_digit_value > high_limit)
        {
            status = 0;
            return status;
        }

        *output_field = *input_field;
        *(output_field + 1) = *(input_field + 1);
        *num_input_field_chars = 2;
    }
    else
    {
        /* The second character was not a digit so the input
           field only one digit.  Return a two digit output
           with a leading 0 and return an indication that
           the input field had only one digit.
        ---------------------------------------------------- */
        *output_field = '0';
        *(output_field + 1) = *input_field;
        *num_input_field_chars = 1;
    }

    return status;
}

//
// This routine converts an input timestamp string to an EPICS
// timestamp string of the form mm/dd/yyyy hh:mm:ss.  It is used
// to convert the user specified start and end time strings to
// the standard EPICS timestamp string where the month, day, hour,
// minute, and second fields are always represented by two digits.
// This routine is used to allow the user to represent these fields
// with just one digit if possible without having to remember to
// supply a leading zero to conform to the EPICS timestamp string
// format.  It also allows the user to represent the year field
// with one or two digits rather than four digits.
//
int convert_input_timestamp_to_epics(char *input_timestamp,
                                     char *epics_timestamp)
{
    int status;
    int string_len;
    int cur_input_buffer_index;
    int cur_output_buffer_index;
    int i;
    int num_input_field_chars;
    int year;
    int num_year_digits;
    int num_converted; 
    int date_high_limit[NUM_DATE_TWO_DIGIT_TIMESTAMP_FIELDS] = {12, 31};
    int time_high_limit[NUM_TIME_TWO_DIGIT_TIMESTAMP_FIELDS] = {23, 59, 59}; 

    char input_buffer[EPICS_TIMESTAMP_LENGTH + 1];
    char output_buffer[EPICS_TIMESTAMP_LENGTH + 1];
    char year_field[YEAR_FIELD_LENGTH + 1];
    char year_buffer[YEAR_FIELD_LENGTH + 1];

    /* Logic begins.
    ---------------- */
    status = 1;

    /* Copy the input timestamp string into an input buffer.
    -------------------------------------------------------- */
    strncpy(input_buffer, input_timestamp, EPICS_TIMESTAMP_LENGTH);
    string_len = strlen(input_buffer);
    *(input_buffer + string_len) = '\0';

    /* Throughout this routine, indexes into the input buffer being
       processed and the output buffer being formed will be
       maintained.
    --------------------------------------------------------------- */
    cur_input_buffer_index = 0;
    cur_output_buffer_index = 0;

    /* Loop to process the 2 date two digit timestamp fields, month and
       day.
    ------------------------------------------------------------------- */
    for (i = 0; i < NUM_DATE_TWO_DIGIT_TIMESTAMP_FIELDS; i++)
    {
        /* Convert the current one or two digit input buffer field being
           processed (month or day) into a two digit field stored into
           the next locations of the output buffer.
        ---------------------------------------------------------------- */
        status = convert_to_two_digit_timestamp_field(input_buffer + cur_input_buffer_index,
                                                      date_high_limit[i],
                                                      &num_input_field_chars,
                                                      output_buffer + cur_output_buffer_index);
        if (status != 1)
        {
            return status;
        }

        cur_input_buffer_index += num_input_field_chars;

        /* Check to make sure that the character after the input buffer
           month or day is the "/" character.  Then store this character
           into the next location of the output buffer.
        ---------------------------------------------------------------- */
        if (*(input_buffer + cur_input_buffer_index) != '/')
        {
            status = 0;
            return status;
        }

        cur_output_buffer_index += 2;

        *(output_buffer + cur_output_buffer_index) = '/';

        cur_input_buffer_index++;
        cur_output_buffer_index++;
    }

    /* One, two, or four digit year specifications are allowed (e.g.,
       '9', '09', or '2009').  If the next input character is not
       a digit, this is an error condition (a year specification must
       have at least one digit).  If a three digit year specification
       is made, this is also an error condition.  Unless there is
       an error condition, store each digit of the year specification
       into year_buffer.  Finally, create a four digit year_field
       string using the information in year_buffer formed according
       to whether a one, two, or four digit year specification was
       made.
    ----------------------------------------------------------------- */
    num_year_digits = 0;
    if (!isdigit(*(input_buffer + cur_input_buffer_index)) )
    {
        status = 0;
        return status;
    }

    year_buffer[0] = *(input_buffer + cur_input_buffer_index);

    num_year_digits++;
    cur_input_buffer_index++;

    if (isdigit(*(input_buffer + cur_input_buffer_index)) )
    {
        year_buffer[1] = *(input_buffer + cur_input_buffer_index);

        num_year_digits++;
        cur_input_buffer_index++;

        if (isdigit(*(input_buffer + cur_input_buffer_index)) )
        {
            year_buffer[2] = *(input_buffer + cur_input_buffer_index);

            num_year_digits++;
            cur_input_buffer_index++;

            if (!isdigit(*(input_buffer + cur_input_buffer_index)) )
            {
                status = 0;
                return status;
            }
            year_buffer[3] = *(input_buffer + cur_input_buffer_index);

            num_year_digits++;
            cur_input_buffer_index++;
        }
    }

    switch (num_year_digits)
    {
        case 1:

           year_field[0] = '2';
           year_field[1] = '0';
           year_field[2] = '0';
           year_field[3] = year_buffer[0];

           break;

        case 2:

           year_field[0] = '2';
           year_field[1] = '0';
           year_field[2] = year_buffer[0];
           year_field[3] = year_buffer[1];

           break;

        case 4:

           year_field[0] = year_buffer[0];
           year_field[1] = year_buffer[1];
           year_field[2] = year_buffer[2];
           year_field[3] = year_buffer[3];

           break;
    }

    year_field[YEAR_FIELD_LENGTH] = '\0';

    /* Copy the four digit year field into the next locations in the
       output buffer.
    ---------------------------------------------------------------- */
    strncpy(output_buffer + cur_output_buffer_index, year_field, YEAR_FIELD_LENGTH);
 
    cur_output_buffer_index += YEAR_FIELD_LENGTH;

    /* Check to make sure that the character after the specified four
       digit year is a space.  Then copy a blank into the next
       location in the output buffer. 
    ----------------------------------------------------------------- */
    if (*(input_buffer + cur_input_buffer_index) != ' ')
    {
        status = 0;
        return status;
    }

    *(output_buffer + cur_output_buffer_index) = ' ';

    cur_input_buffer_index++;
    cur_output_buffer_index++;

    /* Loop to process the three time two digit timestamp fields:
       hour, minute, and second.
    ------------------------------------------------------------- */
    for (i = 0; i < NUM_TIME_TWO_DIGIT_TIMESTAMP_FIELDS; i++)
    {
        status = convert_to_two_digit_timestamp_field(input_buffer + cur_input_buffer_index,
                                                      time_high_limit[i],
                                                      &num_input_field_chars,
                                                      output_buffer + cur_output_buffer_index);
        if (status != 1)
        {
            return status;
        }

        /* If we have not finished processing the last field in the
           input buffer (the seconds field), check to make sure that
           the next character is ":" and copy this ":" character into
           the next location of the output buffer.
        ------------------------------------------------------------- */
        if (i < NUM_TIME_TWO_DIGIT_TIMESTAMP_FIELDS - 1)
        {
            cur_input_buffer_index += num_input_field_chars;

            if (*(input_buffer + cur_input_buffer_index) != ':')
            {
                status = 0;
                return status;
            }

            cur_output_buffer_index += 2;

            *(output_buffer + cur_output_buffer_index) = ':';

            cur_input_buffer_index++;
            cur_output_buffer_index++;
       }
    }

    /* Terminate the output buffer string and copy it into the
       output EPICS timestamp string parameter.
    ---------------------------------------------------------- */
    output_buffer[EPICS_TIMESTAMP_LENGTH] = '\0';

    strcpy(epics_timestamp, output_buffer);

    return status;
}


//
// This function converts a EPICS timestamp string in mm/dd/yyyy hh:mm:ss
// format to a Unix time (the number of seconds since the beginning of
// the day of Jan. 1, 1970).
//
int convert_string_to_unix_time(char *time_string,
                               int *unix_time)
{
    int status;
    int num_seconds_since_epoch;

    struct tm tm_time;

    /*** Logic begins */

    status = 1;

    /* Convert the EPICS timestamp string to a struct tm time.
    ---------------------------------------------------------- */
    if (strptime(time_string, "%m/%d/%Y %H:%M:%S", &tm_time) == NULL)
    {
        status = 0;
        return status;
    }

    /* Convert the struct tm time to a Unix timestamp and
       return this to the caller.
    ----------------------------------------------------- */
    tm_time.tm_isdst = -1;

    num_seconds_since_epoch = (int) mktime(&tm_time);

    *unix_time = num_seconds_since_epoch;

    return status;
}

//
// This function gets information about the archiver indexes for
// a specified subsystem that are needed to retrieve archiver data
// between the specified start and end times.  It returns the number
// of these indexes and three arrays, whose elements contain
// information about each index:
//     1.  The full filename path of the archiver index.
//     2.  A string specifying the start time required to
//         retrieve the needed archiver data from the
//         index. 
//     3.  A string specifying the end time required to
//         retrieve the needed archiver data from the
//         index.
// The index information in these arrays are from the most
// recent data (element 0) to the oldest data.
//
int get_index_info(char *subsystem,
                   char *start_string,
                   char *end_string,
                   int *num_indexes,
                   char index_filepath[][MAX_INDEX_FILEPATH_LEN + 1],
                   char data_start[][MAX_TIMESTRING_LEN + 1],
                   char data_end[][MAX_TIMESTRING_LEN + 1])
{
    int status;
    int start_unixtime;
    int end_unixtime;
    int cur_data_start_unixtime;
    int cur_data_end_unixtime;
    int cur_index;
    int cur_index_item;
    int done;

    char subsystem_archiver_indexes_filename[MAX_SUBSYSTEM_ARCHIVER_INDEXES_FILEPATH_LEN + 1];
    char buffer[MAX_BUFFER_LEN + 1];
    char cur_index_filepath[MAX_INDEX_FILEPATH_LEN + 1];
    char cur_data_start[MAX_TIMESTRING_LEN + 1];
    char cur_data_end[MAX_TIMESTRING_LEN + 1];

    FILE *subsystem_archiver_indexes_f_ptr;

    /*** Logic begins */

    status = 1;

    *num_indexes = 0;

    /* Convert the specified start time string in EPICS time string format
       (mm/dd/yyyy hh:mm:ss) to a Unix timestamp so that time comparisons
       can be made.  Then also convert the end time string.
    ---------------------------------------------------------------------- */
    status = convert_string_to_unix_time(start_string, &start_unixtime);
    if (status != 1)
    {
        fprintf(stderr, "error converting start string to Unix time\n");
        return status;
    }

    status = convert_string_to_unix_time(end_string, &end_unixtime);
    if (status != 1)
    {
        fprintf(stderr, "error converting end string to Unix time\n");
        return status;
    }

    /* Return an error flag if the start time is equal to or greater
       than the end time.
    ---------------------------------------------------------------- */
    if (start_unixtime >= end_unixtime)
    {
        status = 0;
        return status;
    }

    /* Open the file containing information for each of the archiver indexes
       for the specified subsystem.  This file contains the following three
       lines of information for each index:
           1.  The full filename path of the archiver index.
           2.  A string specifying the start time of archiver data for the index.
           3.  A string specifying the end time of archiver data for the index
               (or "now" for the archiver data index containing the recent
               archiver data and is continually being updated).
       The index information is from the most current archiver data index to
       the oldest archiver data index.
    ----------------------------------------------------------------------------- */
    strcpy(subsystem_archiver_indexes_filename, AIDA_ARCHIVER_INDEXES_DIR);
    strcat(subsystem_archiver_indexes_filename, "/");
    strcat(subsystem_archiver_indexes_filename, subsystem);
    strcat(subsystem_archiver_indexes_filename, AIDA_ARCHIVER_INDEXES_FILENAME_SUFFIX); 

    if ((subsystem_archiver_indexes_f_ptr = fopen(subsystem_archiver_indexes_filename, "r")) == NULL)
    {
        fprintf(stderr, "Cannot open file %s\n", subsystem_archiver_indexes_filename);
        return 0;
    }

    /* Loop through each line of the file containing information for each of
       the archiver indexes for the specified subsystem or until enough index
       information has been read to find all of the indexes needed to retrieve
       archiver data from the specified start and end times.  The cur_index
       variable contains the current index offset and the cur_index_item
       variable contains the offset for the current line number (0, 1, or 2)
       of the three lines of information for the current index.
    -------------------------------------------------------------------------- */
    cur_index = 0; 
    cur_index_item = 0;
    done = 0;
    while ((fgets(buffer, sizeof(buffer), subsystem_archiver_indexes_f_ptr) != NULL) &&
           (!done))
    {
        strtok(buffer, "\n");

        switch (cur_index_item)
        {
            case 0:

                /* The first line for each index contains the full file path
                   for the index.
                ------------------------------------------------------------ */ 
                strcpy(cur_index_filepath, buffer);

                break;

            case 1:

                /* The second line for each index contains a string that
                   specifies the index start time for archiver data.
                -------------------------------------------------------- */
                strcpy(cur_data_start, buffer);

                break;

            case 2:

                /* The third line for each index contains a string that
                   specifies the index end time for archiver data (or
                   "now" for the first index, which is associated with
                   the most recent archiver data).
                ------------------------------------------------------- */
                strcpy(cur_data_end, buffer);

                break;
        }
 
        if (cur_index_item >= 2)
        {
            /* Each of the three lines for the current index has now been read and
               saved.  Convert the saved start time for the current index to Unix
               time so this time can be compared.
            ---------------------------------------------------------------------- */
            status = convert_string_to_unix_time(cur_data_start, &cur_data_start_unixtime);
            if (status != 1)
            {
                fprintf(stderr, "error converting cur_data_start string to Unix time for cur_index = %d\n", cur_index);
                return status;
            }

            if (start_unixtime >= cur_data_start_unixtime)
            {
                /* The specified start time is greater than or equal to the start
                   time for the current index being processed.  This means that
                   no more index information needs to be read and processed because
                   the current index being processed contains the last index that
                   is needed (since index information in the file is from most
                   recent to oldest).
                ------------------------------------------------------------------- */
                done = 1;

                strcpy(index_filepath[*num_indexes], cur_index_filepath);

                /* Set the returned start time for the current index being processed
                   to the specified start time.  If this index is the first index
                   (containing the most recent archiver data), set the returned
                   end time for the current index being processed to the
                   specified end string.
                -------------------------------------------------------------------- */ 
                strcpy(data_start[*num_indexes], start_string);

                if (cur_index == 0)
                {
                    strcpy(data_end[*num_indexes], end_string); 
                }
                else
                {
                    /* The current index being processed is not the first
                       index.  If the specified end time is greater than
                       the end time for the current index being processed,
                       set the returned end time for the current index
                       being processed to the end time for data from this
                       index.  Otherwise, set the returned end time for
                       the current index being processed to the specified
                       end string.
                    ------------------------------------------------------ */
                    status = convert_string_to_unix_time(cur_data_end, &cur_data_end_unixtime);
                    if (status != 1)
                    {
                        fprintf(stderr, "error converting cur_data_end string to Unix time for cur_index = %d\n",
                            cur_index);
                        return status;
                    }

                    if (end_unixtime > cur_data_end_unixtime)
                    {
                        strcpy(data_end[*num_indexes], cur_data_end); 
                    }
                    else
                    {
                        strcpy(data_end[*num_indexes], end_string); 
                    }
                }

                *num_indexes = *num_indexes + 1;
            }
            else
            {
                if (end_unixtime >= cur_data_start_unixtime)
                {
                    /* The specified start time is not greater than or equal to the
                       start time for the current index being processed but the
                       specified end time is.  This means that this index is needed
                       to retrieve the requested archiver data but it is not the
                       last index information that must be read and processed.
                    --------------------------------------------------------------- */
                    strcpy(index_filepath[*num_indexes], cur_index_filepath);

                    /* Set the returned start time for the current index being processed
                       to the specified start time.  If this index is the first index
                       (containing the most recent archiver data), set the returned
                       end time for the current index being processed to the
                       specified end string.
                    -------------------------------------------------------------------- */ 
                    strcpy(data_start[*num_indexes], cur_data_start);

                    if (cur_index == 0)
                    {
                        strcpy(data_end[*num_indexes], end_string); 
                    }
                    else
                    {
                        /* The current index being processed is not the first
                           index.  If the specified end time is greater than
                           the end time for the current index being processed,
                           set the returned end time for the current index
                           being processed to the end time for data from this
                           index.  Otherwise, set the returned end time for
                           the current index being processed to the specified
                           end string.
                        ------------------------------------------------------ */
                        status = convert_string_to_unix_time(cur_data_end, &cur_data_end_unixtime);
                        if (status != 1)
                        {
                            fprintf(stderr, "error converting cur_data_end string to Unix time for cur_index = %d\n",
                                cur_index);
                            return status;
                        }

                        if (end_unixtime > cur_data_end_unixtime)
                        {
                            strcpy(data_end[*num_indexes], cur_data_end); 
                        }
                        else
                        {
                            strcpy(data_end[*num_indexes], end_string); 
                        }
                    }

                    *num_indexes = *num_indexes + 1;
                }

                cur_index_item = 0;
                cur_index++;
            }
        }
        else
        {
            cur_index_item++;
        }
    }

    fclose(subsystem_archiver_indexes_f_ptr);

    return status;
}

static bool in_progress = false;  // wait if call in progress 

// #define DEBUG_LOCAL 1        // Do couts below if defined 

// For communication sigint_handler -> main loop
// main.cpp used this.  exception handler not implemented here yet.
static bool runit = true;

//
// IDL:dp.aida.slac.stanford.edu/dpTestHist:1.0
//

//
// IDL:dp.aida.slac.stanford.edu/dpTestHist/DpChadsI:1.0
//
dpChads::DpChadsI_impl::DpChadsI_impl(PortableServer::POA_ptr poa)
    : poa_(PortableServer::POA::_duplicate(poa))
{
}

// RONM added this two argument constructor to what was generated by IDL.
// George/Greg also did the same to get things to work.
// I'm not sure why IDL doesn't generate this constructor.

dpChads::DpChadsI_impl::DpChadsI_impl(CORBA::ORB_ptr orb, PortableServer::POA_ptr poa, long numTestElms)
  : orb_(CORBA::ORB::_duplicate(orb)),
    poa_(PortableServer::POA::_duplicate(poa))
{
#ifdef DEBUG
  cout << "Constructing dpChads_impl." << endl;
#endif

  char err_a[100];                        // Holds error message
  cerr_p = new chadsErrlog("AIDA", false);                // Error logger.

#ifdef DEBUG
  cout << "The Max Number of Dynamic History Elements has been set to " 
       << DP_HIST_MAX_ELEMENTS << endl;
#endif

  // Maximum sized histData (idl defined) structure to hold history data.
  // Define here and set max. size for efficency.  
  // See Advanced C++ Corba book for 
  // a discussion of constructing and setting length of unbounded sequences.

  static histData hdBig;
  hdBig.d.length(DP_HIST_MAX_ELEMENTS);    // set maximum length.
  hdBig.s.length(DP_HIST_MAX_ELEMENTS);  
  hdBig.repCnt_l.length(DP_HIST_MAX_ELEMENTS);
  hdBig.unixtime.length(DP_HIST_MAX_ELEMENTS);
  hdBig.pulseid.length(DP_HIST_MAX_ELEMENTS);
  hdBig.count.length(DP_HIST_MAX_ELEMENTS);
  hdBig.isdst.length(DP_HIST_MAX_ELEMENTS);
  hdBig_p = &hdBig;

  // This is a static structure filled with hard coded data.
  // It is used for running the server in a mode that does not fetch
  // data from channel archiver.  It returns this instead.
  // If we're returning real history data, numTestElms = 0.

  num_test_elems = numTestElms;

#ifdef DEBUG
  cout << "The Max Number of Static Test History Elements has been set to " 
       << num_test_elems << endl;
#endif

  static histData hdStatic;
  hdStatic.d.length(num_test_elems);    // set maximum length.
  hdStatic.s.length(num_test_elems);
  hdStatic.repCnt_l.length(num_test_elems);
  hdStatic.unixtime.length(num_test_elems);
  hdStatic.pulseid.length(num_test_elems);
  hdStatic.count.length(num_test_elems);
  hdStatic.isdst.length(num_test_elems);
  hdStatic_p = &hdStatic;

  // Fill it with dummy hard coded values.

  for (int hdIx=0; hdIx < num_test_elems; hdIx++)
    {
      hdStatic.d[hdIx] = CORBA::Long(hdIx + 0.123456789012345678901); 
      hdStatic.s[hdIx] = CORBA::string_dup("10/10/2001 12:23:00.000000000");
      hdStatic.repCnt_l[hdIx] = CORBA::Long(hdIx);
      hdStatic.unixtime[hdIx] = CORBA::Long(hdIx);
      hdStatic.pulseid[hdIx] = CORBA::Long(hdIx);
      hdStatic.count[hdIx] = CORBA::Long(hdIx);
      hdStatic.isdst[hdIx] = CORBA::Long(hdIx);
    }

#ifdef DEBUG
  cout << "dpChads_impl Construction Complete." << endl;
#endif
}


dpChads::DpChadsI_impl::~DpChadsI_impl()
{
}

PortableServer::POA_ptr
dpChads::DpChadsI_impl::_default_POA()
{
    return PortableServer::POA::_duplicate(poa_);
}


//
// IDL:dp.aida.slac.stanford.edu/dpChads/DpChadsI/get:1.0
//
// Arguments:
//   target - contains the PV that you're fetching.
//   args   - Time range specified by caller of Da.
// 

CORBA::Any*
dpChads::DpChadsI_impl::get(const char* target,
                                  const CORBA::StringSeq& args)
    throw(except::UnableToGetDataException,
          CORBA::SystemException)
{

#ifdef DEBUG_LOCAL
  cout << "ENTERING GET METHOD ****" << endl;
  // THIS IS HOW WE SHOULD LOG IN THIS METHOD.
  cerr_p->log("TESTTESTTEST***********");
#endif

  char err_a[100];      // Holds error messages

  ListIndex index[MAX_NUM_SUBSYSTEM_INDEXES];
  DataReader* reader; 

#ifdef DEBUG_TRACE
  time_t cur_time;

  char *time_str;

  char trace_err[150];
  char trace_file[100];

  FILE *trace_file_p; 
 
  char * subsystem = getenv("ARCHIVER_SUBSYSTEM");

  if (strcmp(subsystem, "lcls") == 0)
  { 
    strcpy(trace_file, "/nfs/slac/g/archiver/arch_lcls/log/aida_lcls_trace.txt");
  }
  else if (strcmp(subsystem, "facet") == 0)
  {
    strcpy(trace_file, "/nfs/slac/g/archiver/arch_facet/log/aida_facet_trace.txt");
  }
  else if (strcmp(subsystem, "pepii") == 0)
  {
    strcpy(trace_file, "/nfs/slac/g/archiver/pepii_top/aida_pepii_trace.txt");
  }
  else if (strcmp(subsystem, "nlcta") == 0)
  {
    strcpy(trace_file, "/nfs/slac/g/cd_archiver/tarf/tarf_top/aida_nlcta_trace.txt");
  }
  else if (strcmp(subsystem, "dev") == 0)
  {
    strcpy(trace_file, "/nfs/slac/g/cd_archiver/dev/data/aida_dev_trace.txt");
  }
  else
  {
    strcpy(trace_file, "/nfs/slac/g/archiver/pepii_top/aida_unknown_trace.txt");
  }

  cur_time = time(NULL);

  time_str = ctime(&cur_time);

  strcpy(trace_err, time_str);
  //strcat(trace_err, " Entering get method ----------------------------------------------\n");

  trace_file_p = fopen(trace_file, "a");
  fputs(trace_err, trace_file_p);
  fclose(trace_file_p); 
   
#endif

  // static chadsErrlog err("AIDA");                // Error logger.

  // Enforce single threadedness.
  // If this method was entered already, wait for previous entry to finish.
  // For some reason, DA is allowing multiple entries even if I set 'threaded'
  // server.  See Orbacus manual section on concurrancy for details.

  static struct timeval previous_time;
  static struct timeval current_time;
  int sts;
  int num_waits = 0;   // sanity check on waiting for prev call complete.

#define MAX_SECS_WAIT 60   // Total # seconds to wait for previous request to finish
#define WAIT_MS_BETWEEN_RETRIES 200 // Check if previous request finished this 
                                    // often in Millisec.
#define MAX_RETRIES_WAIT  (MAX_SECS_WAIT * 1000) / WAIT_MS_BETWEEN_RETRIES

wait_top:

  if (in_progress) {
    // If you want to do timing tests on the delay code, uncomment this and below.
    // cout << "waiting 200 ms, in progress is true" << endl;
    // sts = gettimeofday(&previous_time, NULL);
    if (num_waits++ > MAX_RETRIES_WAIT) {
      cerr << "Giving up. TOO MANY RETRIES WAITING FOR PREV CALL TO EXIT." 
	   << target << endl;
      // I used to return something like this.  But, now we throw instead.
      // CORBA::Any* _r = new CORBA::Any;
      // hdBig_p->s.length(0);    // We're going to transmit this hd, so
      // hdBig_p->d.length(0);    // reset maximum length to the actual length.
      // hdBig_p->repCnt_l.length(0);
      // hdBig_p->unixtime.length(0);
      // hdBig_p->pulseid.length(0);
      // hdBig_p->count.length(0);
      // hdBig_p->isdst.length(0);
      // *_r <<= *hdBig_p;        // stream the hd structure into an any for return.
      //
      strcpy(err_a, " for "); 
      strcat(err_a, target);
      strcat(err_a, " while previous request in progress in get Any. ");
      cerr_p->log(except::Timeout(), err_a);

#ifdef DEBUG_TRACE
      strcpy(trace_err, err_a);
      strcat(trace_err, "\n"); 
      trace_file_p = fopen(trace_file, "a");
      fputs(trace_err, trace_file_p);
      fclose(trace_file_p); 
#endif

      throw except::UnableToGetDataException();
    }                 

    my_delay((long)WAIT_MS_BETWEEN_RETRIES);    

    /***************  This is timing test on the delay code.
    sts = gettimeofday(&current_time, NULL);
    cout << "elpased time was" << endl;
    cout << "sec: " <<  previous_time.tv_sec << ", usec: " << previous_time.tv_usec
	 << endl;
    cout << "sec: " <<  current_time.tv_sec << ", usec: " << current_time.tv_usec
	 << endl;
    ******************/

    goto wait_top;  // keep looping until previous call is finished or timeout.
  }
 
  in_progress = true;

  CORBA::Any* _r = new CORBA::Any; // holds data returned.

  try {

  // If we're running as a server that does not fetch real history,
  // return dummy hard coded static values instead.

  if (num_test_elems > 0) 
    {  
#ifdef DEBUG_LOCAL
      cout << "Returning dummy data.  Not fetching real history data" << endl;
#endif
      try {
	*_r <<= *hdStatic_p;  // stream the hd structure into an any for return.
	in_progress = false;
      }
      catch (...) {
        cerr_p->log("Exception while streaming into any in static data test" );
        throw except::UnableToGetDataException();
      }
      return _r;
    }

  int repeat_floor = 0;       // This was in archiver main.cpp. Just set it to zero.
  int numEntries = 0;         // Number of history items.
  int cdIx = 0;               // array of channel data index
  int num_values = 0;         // Number of values (for waveforms, the total of all values)

#ifdef DEBUG_LOCAL
  cout << "Entering DpCaHistI_impl::get() ! " << endl;
  cout << "target = " << target     << endl 
       << "  args[0] = " << args[0] << endl
       << "  args[1] = "  << args[1] << endl
       << "  args[2] = " << args[2] << endl
       << "  args[3] = "  << args[3] << endl;
#endif

  // *** This code was copied from Channel Archiver manager.list_values()
  // stdString archive_name = "/nfs/slac/g/esd/archiver/pepii/data/multi_archive.txt";
  //
  // stdString archive_name = getenv("ARDATAFILES");
  // archive_name = archive_name + "/multi_archive.txt";

  // Chop off the Attribute (//HIST) off the end of the target.
  char *slash_loc;
  if ((slash_loc = strchr(target,'/')) != NULL) {          // If / is in string
    memset((void *) slash_loc, 0, 1);                               // null terminate at /
  }  

  stdString channel_name = target;

  // Example ways to set the parameters FYI:
  //
  // stdString channel_name = "HR23:CAV1:VACM";
  // Start time as mm/dd/yyyy hh:mm:ss[.nano-secs]
  // CmdArgString start_text   = "10/10/2001 12:20:00";
  // CmdArgString end_text     = "10/10/2001 12:40:00";
  // string2osiTime (start_text, start);
  // string2osiTime (end_text, end);
  //

  struct tm *tm_time_ptr;

  time_t sample_time;

  epicsTime start, end;
  epicsTime cur_sample_time;

  epicsTimeStamp cur_sample_timestamp;
 
  stdString start_str;
  stdString end_str;

  bool gotend = false;                  // Parse the start and end times passed in.
  bool gotstart = false;

  int i;
  int month_num;
  int num_converted;
  int seconds_past_epoch;
  int pulse_id;
  int cur_value_count;
  int old_prefix;
  int is_dst;
  int num_indexes;
  int cur_index_offset;
  int subsystem_index;
  int ret_status;

  unsigned long nanosecs;

  char month_str[3];
  char dateformat[21];
  char time_text_str[23];
  char dateform0_str[21];
  char input_timestamp[20];
  char epics_timestamp[20];
  char data_density[7];

  char index_filepath[MAX_NUM_SUBSYSTEM_INDEXES][MAX_INDEX_FILEPATH_LEN + 1];
  char data_start[MAX_NUM_SUBSYSTEM_INDEXES][MAX_TIMESTRING_LEN + 1];
  char data_end[MAX_NUM_SUBSYSTEM_INDEXES][MAX_TIMESTRING_LEN + 1];

  char months[][4] = {"Jan", "Feb", "Mar",
                      "Apr", "May", "Jun",
                      "Jul", "Aug", "Sep",
                      "Oct", "Nov", "Dec"};

  strcpy(dateformat, "DATEFORM0");
  strcpy(data_density, "SPARSE");

  // Convert the input
  // by inserting a 0 character.  Previously, string2epicsTime would not
  // return an error when a single digit hour was specified but would not
  // also not convert to the correct "epicsTime" value.
  //
  for (i = 0; i < args.length(); i += 2)
  {
      //std::cout << "args[i] = " << args[i] << "\n";
      //std::cout << "args[i + 1] = " << args[i + 1] << "\n";

      if (strncmp(args[i], "START", 5) == 0)
      {
          strncpy(input_timestamp, args[i + 1], 19);

          ret_status = convert_input_timestamp_to_epics(input_timestamp, epics_timestamp);
          if (ret_status)
          {
              start_str = epics_timestamp;
              if (string2epicsTime (start_str, start))
              {
                  gotstart = true;
              }
          }
      }
      else if (strncmp(args[i], "END", 3) == 0)
      {
          strncpy(input_timestamp, args[i + 1], 19);

          ret_status = convert_input_timestamp_to_epics(input_timestamp, epics_timestamp);
          if (ret_status)
          {
              end_str = epics_timestamp;
              if (string2epicsTime (end_str, end))
              {
                  gotend = true;
              }
          }
      }
      else if (strncmp(args[i], "DATEFORMAT", 10) == 0)
      {
          strcpy(dateformat, args[i + 1]);
      }
      else if (strncmp(args[i], "DENSITY", 7) == 0)
      {
          strncpy(data_density, args[i + 1], 6);
          data_density[6] = '\0';
      }

  }

  //std::cout << "dateformat = " << dateformat << "\n";

  // gotstart = false;  // debug

  if (!gotstart || !gotend) {
    cout << "START or END incorrect in get Any" << "\n";
    cerr_p->log(except::BadArguments(), " START or END time is incorrect " );

#ifdef DEBUG_TRACE
    strcpy(trace_err, "START or END incorrect in get Any\n");
    trace_file_p = fopen(trace_file, "a");
    fputs(trace_err, trace_file_p);
    fclose(trace_file_p); 
#endif

    in_progress = false;
    throw except::UnableToGetDataException();
  }

#ifdef DEBUG_TRACE
  strcpy(trace_err, "channel_name = ");
  strcat(trace_err, channel_name.c_str());
  strcat(trace_err, " start time = ");
  strcat(trace_err, start_str.c_str());
  strcat(trace_err, " end time = ");
  strcat(trace_err, end_str.c_str());
  strcat(trace_err, " dateformat = ");
  strcat(trace_err, dateformat);
  strcat(trace_err, "\n"); 
  trace_file_p = fopen(trace_file, "a");
  fputs(trace_err, trace_file_p);
  fclose(trace_file_p); 
#endif


  if (start >= end)
  {
    cout << "START time must be before END time" << "\n";
    cerr_p->log(except::BadArguments(), " START time must be before END time " );

#ifdef DEBUG_TRACE
    strcpy(trace_err, "START time must be before END time\n");
    trace_file_p = fopen(trace_file, "a");
    fputs(trace_err, trace_file_p);
    fclose(trace_file_p); 
#endif

    in_progress = false;
    throw except::UnableToGetDataException();
  }

  // Examples of how to specify parameters FYI:

  // string2osiTime (args[1], start);
  // string2osiTime (args[3], end);

  // char start_text[20] = "10/10/2001 12:20:00";
  // char end_text[20]   = "10/10/2001 12:40:00";
  // string2osiTime (start_text, start);
  // string2osiTime (end_text, end);

  // OLD dpTestHist_impl way, worked.
  // osiTime start, end;
  // string2osiTime ("10/10/2001 12:20:00", start);
  // string2osiTime ("10/10/2001 12:40:00", end);

  // This was in Chads**
  // string2osiTime (startT_p, start);
  // string2osiTime (endT_p, end);

  stdString time_text, stat_text;
  stdString cur_start_str;
  stdString cur_end_str;
  stdString cur_start_str_debug;
  stdString cur_end_str_debug;

  double dbl;
  double delta;

  const RawValue::Data *value_p;

  stdVector<stdString> names;
  names.push_back(channel_name);

  stdString index_name;

  char subsystem_and_density[21];

  //
  // If the subsystem is "lcls" and the DENSITY parameter was
  // set to SPARSE, set the "subsystem_and_density" argument to
  // indicate to the get_index_info function that a file
  // containing the names of indexes for sparsified archiver
  // data will be used to retrieve archiver data.
  //
  if ((strcmp(subsystem, "lcls") == 0) &&
      (strcmp(data_density, "SPARSE") == 0))
  {
      strcpy(subsystem_and_density, "lcls_sparce");
  }
  else if ((strcmp(subsystem, "facet") == 0) &&
      (strcmp(data_density, "SPARSE") == 0))
  {
      strcpy(subsystem_and_density, "facet_sparce");
  }
  else
  {
      strcpy(subsystem_and_density, subsystem);
  }
 
  // 
  // Get the index information for the subsystem and the specified start
  // and end times.  This information consists of the number of required
  // indexes to get the archiver data and for each index, the index
  // filepath, the data start, and the data end.
  // 
  ret_status = get_index_info(subsystem_and_density,
                              (char *) start_str.c_str(),
                              (char *) end_str.c_str(),
                              &num_indexes,
                              index_filepath,
                              data_start,
                              data_end);
  if (!ret_status)
  {
      strcpy(err_a, "Error return from get_index_info"); 
      cerr_p->log(except::UnableToGetDataException(), err_a);

#ifdef DEBUG_TRACE
      strcpy(trace_err, err_a);
      strcat(trace_err, "\n");
      trace_file_p = fopen(trace_file, "a");
      fputs(trace_err, trace_file_p);
      fclose(trace_file_p); 
#endif

      in_progress = false;
      throw except::UnableToGetDataException();

  }

#ifdef DEBUG_TRACE2
  trace_file_p = fopen(trace_file, "a");
  for (i = 0; i < num_indexes; i++)
  {
      strcpy(trace_err, "index_filepath = ");
      strcat(trace_err, index_filepath[i]);
      strcat(trace_err, " data start = ");
      strcat(trace_err, data_start[i]);
      strcat(trace_err, " data end = ");
      strcat(trace_err, data_end[i]);
      strcat(trace_err, "\n"); 
      fputs(trace_err, trace_file_p);
  }
  fclose(trace_file_p); 
#endif

  ReaderFactory::How how = ReaderFactory::Raw;

  hdBig_p->d.length(DP_HIST_MAX_ELEMENTS);    // Set maximum length of all sequences
  hdBig_p->s.length(DP_HIST_MAX_ELEMENTS);    // We will reset to actual length at 
  hdBig_p->repCnt_l.length(DP_HIST_MAX_ELEMENTS);  // the end of the fetch below.
  hdBig_p->unixtime.length(DP_HIST_MAX_ELEMENTS);
  hdBig_p->pulseid.length(DP_HIST_MAX_ELEMENTS);
  hdBig_p->count.length(DP_HIST_MAX_ELEMENTS);
  hdBig_p->isdst.length(DP_HIST_MAX_ELEMENTS);

  //
  // Loop for each required index from the index with the oldest required data to
  // the index with the newest required data.
  //
  for (cur_index_offset = num_indexes - 1, subsystem_index = 0; cur_index_offset >= 0; cur_index_offset--, subsystem_index++)
  {
      index_name = index_filepath[cur_index_offset];

      cur_start_str = data_start[cur_index_offset];
      string2epicsTime(cur_start_str, start);

      cur_end_str = data_end[cur_index_offset];
      string2epicsTime(cur_end_str, end);

#ifdef DEBUG_TRACE2
      epicsTime2string(start, cur_start_str_debug);
      epicsTime2string(end, cur_end_str_debug);

      strcpy(trace_err, "index_name = ");
      strcat(trace_err, index_name.c_str());
      strcat(trace_err, " start = ");
      strcat(trace_err, cur_start_str_debug.c_str());
      strcat(trace_err, " end = ");
      strcat(trace_err, cur_end_str_debug.c_str());
      strcat(trace_err, "\n");
      trace_file_p = fopen(trace_file, "a");
      fputs(trace_err, trace_file_p);
      fclose(trace_file_p); 
#endif

//    
//    Open the index file.  NOTE: the ListIndex "index" variable
//    must be an array since it cannot be reused.  That is, the
//    ListIndex "close" function does not close it for reuse.
//
      if (!index[subsystem_index].open(index_name.c_str()))
      {
          strcpy(err_a, "Error return from index open"); 
          cerr_p->log(except::UnableToGetDataException(), err_a);

#ifdef DEBUG_TRACE
          strcpy(trace_err, err_a);
          strcat(trace_err, "\n");
          trace_file_p = fopen(trace_file, "a");
          fputs(trace_err, trace_file_p);
          fclose(trace_file_p); 
#endif

          in_progress = false;
          throw except::UnableToGetDataException();
      }

      delta = 0.0;
      reader = ReaderFactory::create(index[subsystem_index], how, delta);
      if (!reader)
      {
          index[subsystem_index].close();

          strcpy(err_a, "Error return from attempting to create ReaderFactory"); 
          cerr_p->log(except::UnableToGetDataException(), err_a);

#ifdef DEBUG_TRACE
          strcpy(trace_err, err_a);
          strcat(trace_err, "\n");
          trace_file_p = fopen(trace_file, "a");
          fputs(trace_err, trace_file_p);
          fclose(trace_file_p); 
#endif

          in_progress = false;
          throw except::UnableToGetDataException();
      }

#ifdef DEBUG_TRACE2
      strcpy(trace_err, "calling DataReader find method\n");
      trace_file_p = fopen(trace_file, "a");
      fputs(trace_err, trace_file_p);
      fclose(trace_file_p); 
#endif

      value_p = reader->find(names[0], &start);
      if (! value_p)
      {
          delete reader;
          index[subsystem_index].close();

          strcpy(err_a, " for channel "); 
          strcat(err_a, channel_name.c_str());
          strcat(err_a, " data for specified time period is unavailable");
          cerr_p->log(except::UnableToGetDataException(), err_a);

#ifdef DEBUG_TRACE
          strcpy(trace_err, err_a);
          strcat(trace_err, "\n");
          trace_file_p = fopen(trace_file, "a");
          fputs(trace_err, trace_file_p);
          fclose(trace_file_p); 
#endif

          in_progress = false;
          throw except::UnableToGetDataException();
      }

#ifdef DEBUG_TRACE2
      strcpy(trace_err, "returned from DataReader find method\n");
      trace_file_p = fopen(trace_file, "a");
      fputs(trace_err, trace_file_p);
      fclose(trace_file_p); 
#endif


#ifdef DEBUG_LOCAL
      std::cout << "Channel " << channel_name.c_str() << "\n";
#endif

      if (! reader->channel_found)
      {
          delete reader;
          index[subsystem_index].close();

          strcpy(err_a, " for channel "); 
          strcat(err_a, channel_name.c_str());
          strcat(err_a, " unable to find channel");
          cerr_p->log(except::UnableToGetDataException(), err_a);

#ifdef DEBUG_TRACE
          strcpy(trace_err, err_a);
          strcat(trace_err, "\n");
          trace_file_p = fopen(trace_file, "a");
          fputs(trace_err, trace_file_p);
          fclose(trace_file_p); 
#endif

          in_progress = false;
          throw except::UnableToGetDataException();
      }

      // **LOOP, we'll go through the data, storing it in the sequence.
      // The sequence here, was set up in constructor and has max. size set..

      char temp_a[100];     // Holds the word "Repeat" for finding repeat count.
      long repCnt;          // Repeat count.
      char* str_p;          // C style string pointer

#ifdef DEBUG_TRACE2
      strcpy(trace_err, "starting data retrieval find loop\n");
      trace_file_p = fopen(trace_file, "a");
      fputs(trace_err, trace_file_p);
      fclose(trace_file_p); 
#endif

      while (runit && value_p) 
      {
          if (&end && RawValue::getTime(value_p) >= end)
          {
              break;
          }

          // Convert the current sample time from epicsTime format to
          // the UNIX timestamp format (the number of seconds since
          // 01/01/1970 00:00:00).  The secPastEpoch field of the
          // epicsTimeStamp structure is the number of seconds since a
          // different "epoch" (01/01/1990 00:00:00).  Therefore to
          // to store the current sample time in UNIX timestamp format,
          // add the secPastEpoch field of the epicsTimeStamp sample
          // value to the number of seconds between 01/01/1970 00:00:00
          // and 01/01/1990 00:00:00.
          //
          cur_sample_time = RawValue::getTime(value_p);
          cur_sample_timestamp = (epicsTimeStamp) cur_sample_time;

          seconds_past_epoch = (int) cur_sample_timestamp.secPastEpoch;
          seconds_past_epoch += NUM_SECONDS_BETWEEN_EPOCHS;

          //
          // Convert the UNIX timestamp format to local time in a
          // "struct tm" format so the tm_isdst can be used to
          // return a flag indicating whether the UNIX timestamp
          // is Daylight Savings Time.
          //
          sample_time = (time_t) seconds_past_epoch;
          tm_time_ptr = localtime(&sample_time);
          is_dst = tm_time_ptr->tm_isdst;

          //
          // Mask out all but the lower 13 bits of the nsec (nanoseconds)
          // field of the epicsTimeStamp structure to obtain the pulse
          // id.
          //
          nanosecs = (unsigned long) cur_sample_timestamp.nsec;
          pulse_id = nanosecs & 0x00001FFF;

          epicsTime2string(RawValue::getTime(value_p), time_text);
          RawValue::getStatus(value_p, stat_text);

          if (RawValue::isInfo(value_p))
          {
#ifdef DEBUG_LOCAL
              std::cout << time_text << "\t           -\t" << stat_text << "\n";
#endif
          } 
          else
          {
              // Now, we extract the repeat count for the current item.
              // TODO: There's probably a Cha way to do this, or at least
              //       a more C++ way.  Can I do a (*value_p)->getRepeatCnt()?
              repCnt = 0;
              str_p = (char *) stat_text.c_str();  // get C style pointer
              // If the word "Repeat is there, extract the count after it.
              if ( (strncmp (str_p, "Repeat", sizeof("Repeat")-1) == 0) &&
                   strlen(str_p) > 0)
              {
                  sscanf(str_p, "%s%d", temp_a, &repCnt);
              }

              // Get the value(s) for the sample.  For a waveform, each value
              // will be stored into the next available element of the "d"
              // (value) array.  For a waveform this value array will be larger
              // than the other returned arrays.

              cur_value_count = reader->getCount();

              hdBig_p->count[cdIx] = cur_value_count;

              for (i = 0; i < cur_value_count; i++)
              {
                  RawValue::getDouble(reader->getType(),
                                      reader->getCount(),
                                      value_p, dbl, i);

                  // Stick the History values into idl structure to be returned.
                  // Corba strings map to char* in c++, not to c++ std::string
                  // nor Epics stdString.

                  hdBig_p->d[num_values] = CORBA::Double(dbl);

                  num_values++;

                  if (num_values >= DP_HIST_MAX_ELEMENTS)
                  {
                      delete reader;
                      index[subsystem_index].close();

                      sprintf(err_a, "%s%s%s%s - %s ", 
                          " too many History Elements for ", target,
                          " CHADS HISTORY times  ",
                          args[1], args[3]);
                      cerr_p->log(except::DataOverflowException(), err_a);

#ifdef DEBUG_TRACE
                      strcpy(trace_err, err_a);
                      strcat(trace_err, "\n");
                      trace_file_p = fopen(trace_file, "a");
                      fputs(trace_err, trace_file_p);
                      fclose(trace_file_p); 
#endif

                      in_progress = false;
                      throw except::UnableToGetDataException();
                  }
              }

              if (strcmp(dateformat, "DATEFORM0") == 0)
              {
                  strcpy(time_text_str, time_text.substr(0, 22).c_str());
                  time_text_str[22] = '\0';
                  strncpy(dateform0_str, time_text_str + 3, 2);
                  strcpy(dateform0_str + 2, "-");

                  strncpy(month_str, time_text_str, 2);
                  month_str[2] = '\0';

                  num_converted = sscanf(month_str, "%d", &month_num);
                  strcpy(dateform0_str + 3, months[month_num - 1]);

                  strcpy(dateform0_str + 6, "-");

                  strncpy(dateform0_str + 7, time_text_str + 6, 13);
                  dateform0_str[20] = '\0';

                  //std::cout << "dateform0_str = " << dateform0_str << "\n";

                  hdBig_p->s[cdIx] =
                    CORBA::string_dup(dateform0_str);
              }
              else if (strcmp(dateformat, "MMDDYYYY") == 0)
              {
                  // Truncate the epics time string (drop off fractions of seconds).
                  // We are returning a string like this: 10/10/2002 12:39:53

                  hdBig_p->s[cdIx] =
                    CORBA::string_dup(time_text.substr(0, 19).c_str());

              }
              else if (strcmp(dateformat, "MMDDYYYY_FRAC") == 0)
              {
                  // Truncate the epics time string (drop off milliseconds).
                  // We are returning a string like this: 10/10/2002 12:39:53.16

                  hdBig_p->s[cdIx] =
                    CORBA::string_dup(time_text.substr(0, 22).c_str());
              }

              hdBig_p->repCnt_l[cdIx] = CORBA::Long(repCnt); 

              hdBig_p->unixtime[cdIx] = seconds_past_epoch;

              hdBig_p->pulseid[cdIx] = pulse_id;

              hdBig_p->isdst[cdIx] = is_dst;

              numEntries++;
              cdIx++;
          }

          value_p = reader->next();
      }

      delete reader; 
      index[subsystem_index].close();

  }

#ifdef DEBUG_TRACE2
  strcpy(trace_err, "leaving data retrieval find loop\n");
  trace_file_p = fopen(trace_file, "a");
  fputs(trace_err, trace_file_p);
  fclose(trace_file_p); 
#endif

  // We'll return the data in this hd thing.  Set it's unbounded sequences
  // to the size computed above.

  // histData hd;
  // hd.d.length(numEntries);   // Set the length computed above.
  // hd.s.length(numEntries);  hdBig.d.length(DP_HIST_MAX_ELEMENTS);    

  hdBig_p->s.length(numEntries);    // We're going to transmit this hd, so
  hdBig_p->d.length(num_values);    // reset maximum length to the actual length.
  hdBig_p->repCnt_l.length(numEntries);
  hdBig_p->unixtime.length(numEntries);
  hdBig_p->pulseid.length(numEntries);
  hdBig_p->count.length(numEntries);
  hdBig_p->isdst.length(numEntries);


#ifdef DEBUG_LOCAL
  std::cout  <<"We set length of histData sequences to: "<< numEntries<< "\n";
#endif

  // Instead of using two hd structure, we just use one.  So this approach 
  // was not taken.  But, the comments are left here for your enjoyment.
  //
  // Copy the data from the max sized structure to our exact-sized structure.
  // We can't use the sequence assignment operator, since that would copy
  // the entire max size.  So, copy it the old fashioned way.

  // TODO*****************
  // See P187 of Advanced Corba for a more efficient way to do this
  // rather than copying the data one byte at a time, use the constructor.
  // Or, why not pre-allocate max size.  Then store directly into the buffer.
  // Then, set length to the resultant, presumably smaller length.

  // for (cdIx=0; cdIx<numEntries; cdIx++) 
  //  {
  //  hd.d[cdIx] = hdBig_p->d[cdIx];
  //  hd.s[cdIx] = CORBA::string_dup(hdBig_p->s[cdIx]);
  //  }

 egress:

#ifdef DEBUG_LOCAL
  std::cout << 
    "Done fetching data.  The number of entries is: " << numEntries <<  "\n";
#endif

  // FOR NOW, RETURN GREG/GEORGE'S histData idl structure instead of using DaValue
  // because DaValue isn't supported under C++..

  // Again, this approach was not taken.
  // Copy histData.d and histData.s created above into any.
  // You don't have a constructor to do it in C++ like you do in Java.
  // *_r <<= hd;

  *_r <<= *hdBig_p;  // stream the hd structure into an any for return.

#ifdef DEBUG_LOCAL
  cout << "ABOUT TO RETURN FROM GET METHOD NO EXCEPTIONS*****" << endl;
#endif

  }                      // end of try
  catch (...) {
    cerr_p->log(except::UnableToGetDataException(), " Failure in get Any");

#ifdef DEBUG_TRACE
    strcpy(trace_err, "Failure in get Any\n");
    trace_file_p = fopen(trace_file, "a");
    fputs(trace_err, trace_file_p);
    fclose(trace_file_p); 
#endif

    in_progress = false;
    throw except::UnableToGetDataException();
  }

  in_progress = false;

#ifdef DEBUG_TRACE2
    strcpy(trace_err, "exiting get method\n");
    trace_file_p = fopen(trace_file, "a");
    fputs(trace_err, trace_file_p);
    fclose(trace_file_p); 
#endif

  return _r;

}   //* end of Any = get()

//
// IDL:dp.aida.slac.stanford.edu/dpChads/DpChadsI/status:1.0
//
CORBA::Long
dpChads::DpChadsI_impl::status()
    throw(CORBA::SystemException)
{
    // TODO: Implementation
    CORBA::Long _r = 0;
    return _r;
}

//
// IDL:dp.aida.slac.stanford.edu/dpChads/DpChadsI/shutdown:1.0
//
void
dpChads::DpChadsI_impl::shutdown()
    throw(CORBA::SystemException)
{
    // TODO: Implementation
}
